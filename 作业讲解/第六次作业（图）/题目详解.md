<h1 style="text-align: center"> 第六次作业题目详解</h1>

[A - 图遍历](#a------)

[B - 独立路径数计算](#b---c---------)



## A - 图遍历

请先参考 `图讲解`。由于这道题节点数不超过 $100$，并且要求访问相邻结点时，按照编号从小到大的顺序访问，我们就使用临接矩阵来建图。因为如果使用邻接表建图想保证有`按照编号从小到大的顺序访问`的话我们就要保证将一个节点插入链表中时是有序的，写起来太繁琐了；而临接矩阵的第二个维度本身就维护了一个有序性，所以我们用临接矩阵来建图。同时在这里还要求实现广搜，广搜的原理请参考`作业讲解/第五次作业（树）/树讲解/二叉树的遍历/层序遍历`一节，这里的实现大同小异（提到深搜，就应该想到递归；提高广搜，就应该想到队）。

第二个问题就是要删除掉一个结点 $\mathrm{k}$ 之后再遍历一次。实际上我们可以再建一个图（也就是再来一个临接矩阵），在建图过程中把所有带 $\mathrm{k}$ 的边都跳过去。当然更好的方法是在遍历过程中直接跳过对 $\mathrm{k}$ 的访问。具体实现上，只需要在第二次调用遍历图的函数之前，加上一句 `vis[k] = 1` 即可。这样按照我们之前的实现，就算不写其他控制语句，也能够自动地跳过对 $\mathrm{k}$ 的访问。

注意要进行多次遍历，在两次遍历之间应该把 `vis` 数组清空，避免上一次的结果影响这一次的遍历。

 ```c
 #include <stdio.h>
 int e[105][105];
 int vis[105];
 
 int readInt() {
     int tem;
     scanf("%d", &tem);
     return tem;
 }
 
 int n, m;
 void dfs(int u) {
     // 标记为已访问
     printf("%d ", u);
     vis[u] = 1;
     // 遍历所有顶点
     for (int v = 0; v < n; v++) { 
         // 如果有边且未访问
         if (e[u][v] && !vis[v])  
             dfs(v);
     }
 }
 
 // 为了大家看着方便，我们就不把队的基本操作封装了
 int que[1005];
 void bfs(int u) {
     int front = 0, rear = -1;
     que[++rear] = u;
     while (front <= rear) {
         int tem = que[front++];
         // 如果这里不判定的话，可能有多个点会将同一个还没被访问的点推入队中
         // 可以把这个判断删掉然后再运行一下样例理解一下
         if(vis[tem] == 1)
             continue;
         vis[tem] = 1;
         printf("%d ", tem);
         for (int v = 0; v < n; v++) 
             if (e[tem][v] && !vis[v]) 
                 que[++rear] = v;
     }
 }
 
 void clear_vis() {
     for (int i = 0; i < n; i++) vis[i] = 0;
 }
 
 int main() {
     n = readInt(), m = readInt();
     for (int i = 0; i < m; i++) {
         int a = readInt(), b = readInt();
         e[a][b] = e[b][a] = 1;
     }
     int del = readInt();
 
     // 从 0 开始遍历
     dfs(0);printf("\n");clear_vis();
     bfs(0);printf("\n");clear_vis();
     vis[del] = 1;dfs(0);printf("\n");clear_vis();
     vis[del] = 1;bfs(0);printf("\n");clear_vis();
     return 0;
 }
 ```



## B - 独立路径数计算

首先注意到这题想让我们以字典序输出路径，也就是访问一个结点的关联边的时候按照编号从小到大的顺序访问。在上一题里我们使用临接矩阵建图搜索的时候，是按照临接边的编号从小到大访问的，这一点不太一样。所以这题里我们可以使用邻接表来建图，在某条链里插入新边时，保证边的编号的有序性。在实现的时候，我们可以使用带哨兵结点的链表，以方便插入，防止写一堆特判语句（利用哨兵结点实现的链表可以参考 `作业讲解/第三次作业（链表）/链表讲解/利用哑结点简化代码`。可以将每条链表的头结点编号都设为 -1，尾结点编号都设为 1005，这样保证将结点有序插入时不用特判有没有前驱后继。

其次就是，这道题很像全排列问题，当你访问到某个新节点的时候不需要进行输出，只需要记录，当走到终点的时候再进行输出。如果你经过某条边访问某个点的时候，就输出对应边的编号，就像下面这样：

```c
typedef struct edge  edge;
typedef struct edge* eptr;

struct edge {
    int id, to;
    eptr nxt;
};
eptr a[1005];
int vis[1005], n;

void dfs(int u) {
    eptr p = a[u];
    vis[u] = 1;
    if(u == n - 1) {
        printf("\n");
        return ;
    }
    for(eptr p = a[u]; p != NULL; p = p -> nxt) 
        if(!vis[p -> to]) {
            printf("%d ", p -> id);
            dfs(p -> to);
        }
}
```

这样的问题是显然假如有下面这样一个图，起点是 $0$，终点是 $3$：

<img src="../../img/graph_2.png">

从起点到终点有两条路径 `1 2` 和 `1 3 4`，但是上面的代码显然只能输出 `1` 一次（因为 `0` 临接到 `1` 输出一次边 `1` 后，就回不来了）。所以我们不能按照上面的写法，在访问的时候输出。而是应该参考全排列的做法，在过程中维护一个已经经过的边的数组，当达到边界时再进行输出（全排列的思路和代码请参考 `作业讲解/第一次作业/作业详解/E-全排列数的生成`）。其实我们想假如我们全排列代码那里不用数组记录，而是访问到一个新的数字就输出一次，那也会发生像这道题一样公共前缀不会重复输出的问题。同时注意到我们这道题不能输出环路，需要用 `vis` 数组来记录在当前的路径上哪些结点被访问过（就像全排列里的 `vis` 记录哪些数组被使用过，这个数组也是需要进行回溯的）。

思考完这两个关键问题后，我们就可以实现这道题了。注意到这题边的编号不会超过 1000，所以很显然不会有超过 1000 个节点，我们假设数据结构题目的数据不至于离谱到故意在这难为你，我们只需要开一个长度为 1000 的链表数组当做临接表即可。同时别忘了，**题目里的边是双向边**。

```c
#include <stdio.h>
#include <stdlib.h>

int readInt() {
    int tem;
    scanf("%d", &tem);
    return tem;
}

// 习惯性地我们还是这么命名吧
typedef struct node  node;
typedef struct node* nptr;

struct node {
    int id, to;
    nptr nxt;
};
// 我们还是利用带哨兵结点的链表
nptr head[1005], tail[1005];

nptr newnode() {
    return (nptr)malloc(sizeof(node));
}

nptr getnode(int id, int to) {
    nptr p = newnode();
    p -> id = id;
    p -> to = to;
    p -> nxt = NULL;
    return p;
}

// 插入的时候有序
void add_edge(int id, int u, int v) {
    nptr p = getnode(id, v);
    nptr q = head[u];
    // 因为有哑结点 1005，所以 q -> nxt 一定不为 NULL
    while(q -> nxt -> id < id) 
        q = q -> nxt;
    p -> nxt = q -> nxt;
    q -> nxt = p;
}

// 记录路径上有哪些边，以及路径的长度
int ans[1005], cnt;
// 记录当前路径访问过哪些节点
int vis[1005], n, m;
void dfs(int u) {
    // 到达了终点，输出路径
    if(u == n - 1) {
        for(int i = 0; i < cnt; i++) 
            printf("%d ", ans[i]);
        printf("\n");
        return ;
    }
    vis[u] = 1;
    for(nptr p = head[u] -> nxt; p -> id != 1005; p = p -> nxt) {
        int v = p -> to;
        if(!vis[v]) {
            ans[cnt++] = p -> id;
            dfs(v);
            cnt--;
        }
    }
    // 回溯
    vis[u] = 0;
}

int main () {
    n = readInt(), m = readInt();
    // 初始化邻接表里的每个链表
    for(int i = 0; i <= 1000; i++) {
        head[i] = getnode(-1, -1);
        tail[i] = getnode(1005, -1);
        head[i] -> nxt = tail[i];
    }
    for(int i = 0; i < m; i++) {
        int id = readInt(), u = readInt(), v = readInt();
        // 一定要双向建边
        add_edge(id, u, v);
        add_edge(id, v, u);
    }
    dfs(0);
    return 0;
}
```

