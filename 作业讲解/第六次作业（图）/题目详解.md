<h1 style="text-align: center"> 第六次作业题目详解</h1>

[A - 图遍历](#a------)

[B - 独立路径数计算](#b---c---------)



## A - 图遍历

请先参考 `图讲解`。由于这道题节点数不超过 $100$，并且要求访问相邻结点时，按照编号从小到大的顺序访问，我们就使用临接矩阵来建图。因为如果使用邻接表建图想保证有`按照编号从小到大的顺序访问`的话我们就要保证将一个节点插入链表中时是有序的，写起来太繁琐了；而临接矩阵的第二个维度本身就维护了一个有序性，所以我们用临接矩阵来建图。同时在这里还要求实现广搜，广搜的原理请参考`作业讲解/第五次作业（树）/树讲解/二叉树的遍历/层序遍历`一节，这里的实现大同小异（提到深搜，就应该想到递归；提高广搜，就应该想到队）。

第二个问题就是要删除掉一个结点 $\mathrm{k}$ 之后再遍历一次。实际上我们可以再建一个图（也就是再来一个临接矩阵），在建图过程中把所有带 $\mathrm{k}$ 的边都跳过去。当然更好的方法是在遍历过程中直接跳过对 $\mathrm{k}$ 的访问。具体实现上，只需要在第二次调用遍历图的函数之前，加上一句 `vis[k] = 1` 即可。这样按照我们之前的实现，就算不写其他控制语句，也能够自动地跳过对 $\mathrm{k}$ 的访问。

注意要进行多次遍历，在两次遍历之间应该把 `vis` 数组清空，避免上一次的结果影响这一次的遍历。

 ```c
 #include <stdio.h>
 int e[105][105];
 int vis[105];
 
 int readInt() {
     int tem;
     scanf("%d", &tem);
     return tem;
 }
 
 int n, m;
 void dfs(int u) {
     // 标记为已访问
     printf("%d ", u);
     vis[u] = 1;
     // 遍历所有顶点
     for (int v = 0; v < n; v++) { 
         // 如果有边且未访问
         if (e[u][v] && !vis[v])  
             dfs(v);
     }
 }
 
 // 为了大家看着方便，我们就不把队的基本操作封装了
 int que[1005];
 void bfs(int u) {
     int front = 0, rear = -1;
     que[++rear] = u;
     while (front <= rear) {
         int tem = que[front++];
         // 如果这里不判定的话，可能有多个点会将同一个还没被访问的点推入队中
         // 可以把这个判断删掉然后再运行一下样例理解一下
         if(vis[tem] == 1)
             continue;
         vis[tem] = 1;
         printf("%d ", tem);
         for (int v = 0; v < n; v++) 
             if (e[tem][v] && !vis[v]) 
                 que[++rear] = v;
     }
 }
 
 void clear_vis() {
     for (int i = 0; i < n; i++) vis[i] = 0;
 }
 
 int main() {
     n = readInt(), m = readInt();
     for (int i = 0; i < m; i++) {
         int a = readInt(), b = readInt();
         e[a][b] = e[b][a] = 1;
     }
     int del = readInt();
 
     // 从 0 开始遍历
     dfs(0);printf("\n");clear_vis();
     bfs(0);printf("\n");clear_vis();
     vis[del] = 1;dfs(0);printf("\n");clear_vis();
     vis[del] = 1;bfs(0);printf("\n");clear_vis();
     return 0;
 }
 ```



## B - 独立路径数计算

