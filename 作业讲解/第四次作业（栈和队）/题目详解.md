<h1 style="text-align: center"> 第四次作业题目详解</h1>

## A - 栈操作

参考 `栈队讲解` 和 `栈.c` 实现即可，就是一道栈的模板题。



## B - C 程序括号匹配检查

这道题有以下几个关键点：

- 文件读入

- 单行注释、多行注释、字符常量、字符串常量中的括号不应该被处理
- 遇到除上述情况及括号外的其它字符，应该直接跳过不管
- 假如说以上三点都处理结束了，从我们的视角来看源程序只有左括号和右括号，那该如何进行匹配？

对于**第一个关键点**，最简单的一个方法就是使用 `freopen`，很多同学对于文件 IO 十分惧怕，因为不知道该如何本地调试。其实文件 IO 相比于正常的控制台输入输出，唯一的区别就变成了输入源输出源变成了文件，其余的地方没有区别。可以参考**选填板子-文件**里的代码，比如我们要从 `in.txt` 读入，那就把 `in.txt` 放在跟源程序一个目录下就可以了。

在进行**最简单的文件读入输出**时，我们通常使用 `freopen`。`freopen` 也就是 `file re open`，文件重定向，只要在主函数一开始写上一行 `freopen("in.txt", "rb", stdin)`（相当于把输入源 stdin 换成了 "in.txt"），那以后的读入代码就什么都不用管了，程序已经把输入从文件取到缓冲区等待我们读取了（如果不理解的话就试着运行一下**选填板子-文件-文件读写_freopen**）。

对于**第二个关键点**，我们其实在之前做过很多次了，遇到这种**字符串模式匹配**的问题，尤其是看到注释的识别，我们就不难想到**状态转移的思想**。如果你还不了解状态转移的思想，可以先去看一下**作业讲解-程序设计基础练习-题目讲解**中第五道题的题解，这里的处理是大同小异的，不过是又多了字符串常量和字符常量，所以在这道题里我们用了以下七个状态：

- 0：普通状态，也就是不在单行注释、多行注释、字符常量、字符串常量中，正常的进行字符读入
- 1：在单行注释里
- 2：在多行注释里，且上一个读到的字符不是 `*`
- 3：在字符串常量里
- 4：在多行注释里，且上一个读到的字符是 `*`
- 5：上一个字符是 `/`（可能要进入单行注释或者多行注释了）
- 6：在字符常量中

作为一个练习，同学们可以试着自己画出这道题的状态转移图。

第三个关键点没什么好说的，直接看第四个关键点。

如果只有左括号 `(`、`{` 和右括号 `)`、`}`，那么该如何进行括号匹配呢？实际上，如果是一个右括号的话，它应该看谁是否跟它匹配？应该是它左面的，第一个还没人匹配的左括号，也就是最后一个进来的且还没有匹配的左括号。如果右括号跟这个左括号匹配，那就会把这个左括号给带走。用一句话概括，就是**左括号入栈，右括号出栈**。

当读入一个左括号时，我们就直接把它加入括号栈（当然题目里还有一个特殊规则，就是如果新进来的左括号是 `{`，此时的栈顶为 `(` 时就应该报错）。当读入一个右括号时，我们查看括号栈栈顶，如果跟这个右括号不匹配，那就报错；如果跟这个右括号匹配，那就让括号栈执行出栈操作。也就是说，括号栈里只可能出现左括号。最后读入完成后，如果括号栈里还有括号，也要报错（这段里的三个报错正好对应了三条规则）。

还有一些其它的细节，比如输出行号什么的，只要我们定义一个结构体和对应结构体类型的栈，在存括号的时候把对应的行号信息存进去就行了（想要维护行号的信息，还要记录一下当前读到了第几行，遇到一个换行符就让这个变量 + 1）。还可以给报错函数封装为一个函数，传入一个结构体根据结构体信息报错，看上去更加简洁。其余细节不过多赘述。



## C - 计算器

在读入的这个地方，注意我们不能像**作业讲解-第一次作业-表达式计算**那么读入，因为那道题里一定是`数字 符号 数字 符号 ...` 形式的，但是这道题符号和符号可能挨着。我一开始想这么读入：

```c
while(scanf("%d", &num)) {
    if(num == 0) {
        // 说明是符号
    } else {
        // 说明是数字
    }
}
```

想利用 `scanf` 返回值的技巧进行读入，因为 `scanf` 的返回值相当于成功匹配的元素的个数，比如假如我写的是 `scanf("%d", &num)`，然后输入了一个 `c`，那 `scanf` 就不会改变 `num` 的值，并且返回 `0`。结果发现输出完全不符合我的预期，de 了一会之后发现，`scanf %d` 会读入 `+` 和 `-`，因为它们可能是数字的一部分。比如对上面的代码输入 `1+1`，那它实际上会分别读入 `1` 和 `+1`，并且两次都返回 `1`。

所以这道题的读入大概要这么写：

```c
// 先将所有输入读入为一整个字符串
gets(str);
int i = 0;
while(str[i]) {
    char op = str[i];
    i++;
    // 如果是 = 直接 break 也行，continue 也不影响结果，就是简洁了点
    if(op == ' ' || op == '=')
        continue;
    // isdigit 是 <ctype.h> 里的，用来判断一个字符是不是数字字符
    if(!isdigit(op)) {
        // 进行操作符的处理
    } else {
        // 读入一整个数字
        double num = op - '0';
        while (isdigit(str[i])) {
            num = num * 10 + (str[i] - '0');
            i++;
        }
        // 放进数字栈
        numStk[numTop++] = num;
    }
}
```

读入数字的时候，只需要直接放进数字栈里即可。

读入操作符的时候，我们就要根据操作符的类型进行操作了，有这么几种情况：

- 如果符号栈为空，或者读入的是 `(`，那就直接让读入的操作符进入符号栈即可
- 如果读入的是 `)`，那就一直让符号栈出栈，直到遇到 `(`（其它的谁来也不行）
- 如果读进来的是其它操作符，那就和栈顶比较优先级，如果栈顶符号优先级 $$\mathrm{\ge}$$ 读入的操作符，就让符号栈弹栈，直到栈为空或者栈顶符号操作符 $$\mathrm{\lt}$$ 读入的操作符或者栈顶为 `(`（实际上，只有可能栈顶是 `*`、`/`，或者读进来的操作符是 `+`、`-` 时才会满足这一点，大家可以写一写各种情况理解一下）。

- 如果处理输入串结束后，符号栈不为空，就将符号栈中的符号依次出栈

同时，符号出栈就伴随着从数字栈栈顶弹出两个元素并计算（后出栈的数字 op 先出栈的数字），对于不同的符号，都经过一个相同的流程：

- 弹出第一个数字 a
- 弹出第二个数字 b
- a op b = c
- 将 c 入栈

所以我们可以直接将这个过程封装为一个函数：

```c
void cal(char c) {
    double a = numStk[--numTop];
    double b = numStk[--numTop];
    if(c == '+') numStk[numTop++] = b + a;
    else if(c == '-')   numStk[numTop++] = b - a;
    else if(c == '*')   numStk[numTop++] = b * a;
    else numStk[numTop++] = b / a;
}
```

这样主函数就会相当简单，比如和栈顶比较优先级的部分，就可以这么实现了：

```c
while (opTop > 0 && cmp(opStk[opTop - 1], op)) 
    cal(opStk[--opTop]);
opStk[opTop++] = op;
```





