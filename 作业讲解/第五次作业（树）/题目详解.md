<h1 style="text-align: center"> 第五次作业题目详解</h1>

[A - 树叶结点遍历](#a------)

[B - 计算器（表达式树实现）](#b---c---------)

[C - 服务优化](#c------)

[D - 词频统计（树实现）](#d-----------)

[实验 - 树的构造与遍历](#e---------)

* [背景知识](#---)
* [Huffman 算法](#-----1)
* [回到题目](#-)

## A - 树叶结点遍历

请先参考 `树讲解`。这道题在正常的二叉查找树的基础上，增加了两点：每个节点增加了一个高度信息；最后从左到右输出所有的叶子结点。

我们在 `树讲解` 中讲过节点插入的流程，大致按照如下递归实现：

```c
void insert(nptr p, int val) {
    if(val < p -> val) {
        if(p -> ls == NULL) {
            p -> ls = getnode(val, p -> dep + 1);
            return;
        } else
            insert(p -> ls, val);
    } else {
        if(p -> rs == NULL) {
            p -> rs = getnode(val, p -> dep + 1);
            return;
        } else
            insert(p -> rs, val);
    }
}

int main() {
    ...
    for(int i = 1; i <= n; i++) {
        if(root == NULL) {
            root = getnode(readInt(), 1);
            continue;
        } else
            insert(root, readInt());
    }
    ...
}
```

可以看到，在插入对应结点的时候，我们把它的高度设置为它要插入的父节点的高度 + 1，这样就能够在插入过程中自动地维护所有结点的高度了。

对于从左到右输出所有的叶子结点，我们可以使用中序遍历，遇到叶子节点的时候再输出（叶子结点的判断条件就是左右孩子都是 NULL）：

```c
void inDfs(nptr p) {
    if(p == NULL) return;
    inDfs(p -> ls);
    if (p -> ls == NULL && p -> rs == NULL)
        printf("%d %d\n", p -> val, p -> dep);
    inDfs(p -> rs);
}

int main() {
    ...
    inDfs(root);
    return 0;
}
```

其实这不管使用前序遍历、中序遍历还是后序遍历都可以，因为在这三种遍历里都是先访问左子树再访问右子树，所以一定都是从左到右输出叶子节点。

  

## B - 计算器（表示式树实现）

又是我们的老朋友表达式计算，不过这题希望我们：输入字符串，表示中缀表达式 $\mathrm{\rightarrow}$ 后缀表达式 $\mathrm{\rightarrow}$ 表达式树 $\mathrm{\rightarrow}$ 算出表达式。为了强迫我们使用表达式树，它最后还让我们输出表达式树的根和左儿子右儿子。

我们再来回顾一下中缀表达式转后缀表达式吧。首先我们假设有两种结点，分别是数字结点和操作符结点，但是我们只用一个结构体来实现，用 `type` 字段标识是数字结点还是操作符结点，如下：

```c
struct node {
	int type;	// 0 表示数字结点，1 表示操作符结点
    int num;	// type = 0 时，表示操作数
    char op;	// type = 1 时，表示操作符
    nptr ls, rs;	// 留给后面建树用
}
```

读入一个非空格、非等号字符时，创建一个字符结点；读入一个数字字符时，一直读入，直到不是数字，创建一个数字结点。

然后就是将字符结点和数字结点推入栈中时的各种规则了，我们只在这回顾一下规则，省得大家去翻了（注意，下面的`输出`是指放到表示后缀表达式的结点数组里）：

- 数字节点直接输出
- `(` 结点直接入符号栈
- 遇到 `)` 结点一直符号栈一直出栈并输出，直到遇到一个 `(` 结点，把这个 `(` 结点也出栈（但是不输出）
- 其余的操作符结点，一直出栈并输出，直到栈为空、栈顶为 `(` 或者栈顶为符号且优先级比新来的操作符低。最后将这个操作符结点入栈
- 直到输入结束，如果符号栈中还有结点，直接输出

总结来说，中缀转后缀的代码大概就是这样：

```c
nptr stack[105], post[105];
int top = -1, cnt = 0;

void push(nptr p) {
    stack[++top] = p;
}

nptr pop() {
    return stack[top--];
}

int pre(char op) {
    switch (op) {
        case '+':
        case '-':
            return 1;
        case '*':
        case '/':
            return 2;
        case '(':
            return 0;
        default:
            return -1;
    }
}

void build_post() {
    int len = strlen(str);
    for(int i = 0; i < len; i++) {
        if(isdigit(str[i])) {
            int num = 0;
            while(isdigit(str[i])) {
                num = num * 10 + str[i] - '0';
                i++;
            }
            nptr p = getnode(0, num, 0);
            post[cnt++] = p;
            // 此时 str[i] 一定不是数字，由此保证有没有进入到这个分支，交给下面分支的都是一个字符
        }
        if(str[i] == ' ')
            continue;
        if(str[i] == '=')
            break;
        if (str[i] == '(') {
            push(getnode(1, 0, str[i]));
        } else if (str[i] == ')') {
            while (top != -1 && stack[top] -> op != '(') {
                post[cnt++] = pop();
            }
            pop();
        } else {  // 处理操作符
            while (top != -1 && pre(stack[top] -> op) >= pre(str[i])) 
                post[cnt++] = pop();
            push(getnode(1, 0, str[i]));
        }
    }

    while(top != -1) {
        post[cnt++] = pop();
    }
}
```

上面的代码段运行结束后，`post` 里存的就是原输入字符串代表的中缀表达式形成的后缀表达式了。下面就按照题目中给出的由后缀表达式建立表达式树的方法来建立表达式树。可以看到该流程中又需要用到一个栈，我们将原来用于中缀转后缀的 `stack` 复用即可（注意在 `build_post` 里，我们最后将栈清空了，此时 `top = -1`，所以我们直接用这个栈即可，不需要做其他任何初始化操作）：

```c
void build_tree() {
    for(int i = 0; i < cnt; i++) {
        // 是数字，直接建立单节点树并入栈，单节点树就相当于带 ls、rs 字段的结点
        if(post[i] -> type == 0) {
            stack[++top] = post[i];
        } else {
            post[i] -> rs = pop();
            post[i] -> ls = pop();
            stack[++top] = post[i];
        }
    }
}
```

上面的操作结束以后，`stack` 中一定只有一个结点，也就是 `stack[0]`，它也就是表达式树的树根。

输出树根、左儿子、右儿子，写一个能传入结点的函数即可：

```c
void printNode(nptr p) {
    if(p == NULL)
        return ;
    if(p -> type == 0)
        printf("%d ", p -> num);
    else 
        printf("%c ", p -> op);
}
```

最后就是利用表达式树计算表达式的过程了，其实对于每个叶子结点，它都是一个操作数，那么它的值就是该数本身；对于每个非叶节点 `op`，它的值就相当于 `左儿子的值 op 右儿子的值`，所以在计算出这个结点的值之前，需要计算出它的左儿子和右儿子的值，所以我们需要使用后序遍历方式：

```c
void postDfs(nptr p) {
    // 递归边界一定是叶子结点，不用考虑空节点了
    // 因为非叶子结点一定有两个儿子，因为这些操作符必须都要有两个操作数
    if(p -> type == 0)
        return ;
    postDfs(p -> ls);
    postDfs(p -> rs);
    p -> num = cal(p -> op, p -> ls -> num, p -> rs -> num);
}
```



## C - 服务优化

这题看上去挺唬人的，不过请仔细读题理解一下他到底要你干啥。

首先输入一棵三叉树，所有 < 100 的结点叫登机口，而且一定是叶子结点。然后输入这些登机口原来的客流量；显然我们希望客流量越高的地方离安检处越近，这样大伙普遍就能走的更少了。所以我们先给这些结点按客流量从高到低排个序。原来的这些登机口，我们把它们从左到右、从上到下都拿出来，然后把它们按照客流量顺序安排成新的登机口，再输出一个`原来登机口 -> 新登机口` 信息。

所以，总结来说就是最后有两个列表，第一个列表是从左到右、从上到下，按照树结构来排列登机口；第二个列表是按照客流量（客流量相等时按编号）排列登机口。这俩列表中的登机口按照位置有一一对应的关系。

首先是创建三叉树，我们想从链表到二叉树，由最多一个后继变为了最多两个，我们就增加了一个指针域；现在无非是变成了三个，所以我们定义结点结构如下：

```c
struct node {
    int id, num;
    // 这里用了一个数组，方便后面依次添加儿子
    // 如果用 ls、ms、rs 这种写法要加很多特判
    nptr son[3];
};
```

这棵树的根题目里保证了一定为 `100`，所以我们可以先建根：

```c
nptr root = getnode(100);	// 写在主函数里，因为全局变量不允许编译时未知的值，而 malloc 分配的空间是运行时才可知的
```

然后，每次先读入一个已有的结点，再读入它的三个儿子，以此来创建树：

```c
nptr p;
void find(nptr q, int n) {
    if(q == NULL)
        return ;
    if(q -> id == n) {
        p = q;
        return ;
    }
    for(int i = 0; i < 3; i++) 
        find(q -> son[i], n);
}

int main() {
    ...
    int n;
    while((n = readInt()) != -1) {
        find(root, n);
        // find 之后，p 就是当前结点
        int m, cnt = 0;
        while((m = readInt()) != -1) {
            nptr q = getnode(m);
            p -> son[cnt++] = q;
        }
    }
}
```

这里有两个关键点：第一是查找已有结点的操作，如果你不理解为什么我一定要像上面那样写的话，请先参考 `树讲解` 里的 `二叉查找树查找操作容易犯的一个 bug` 部分；第二就是在给已有结点添加孩子的过程中，我们就从左往右添加就可以，不用像题目图里的 `110` 号结点一样，有两个孩子好像放在了 `son[0]` 和 `son[2]` 的位置，这样的好处是我们不用每次特判需要放在哪，直接往上填就行了。

建树过程完毕，第二步读入每个登机口的客流量，并给他们排序。这的操作其实很简单，我们为了方便在这里新开了一个 `node` 数组（而不是 `nptr` 数组），然后直接排序就可以了：

```c
int cmp(const void *a, const void *b) {
    node *x = (node *)a;
    node *y = (node *)b;
    if(x -> num == y -> num)
        return x -> id - y -> id;
    return y -> num - x -> num;
}

int main() {
    ...
    int id, num, i = 0;
    // 不定组输入，结束输入用 ctrl + z
    // 你也可以提前维护有几个登机口，来变成定组输入
    while(scanf("%d %d", &id, &num) != EOF) {
        a[i].id = id, a[i].num = num;
        i++;
    }
	// 这里 i 保存了有几个登记口，你也可以通过查找树上有几个 id < 100 的结点来维护 i
    // 不过显然通过读入登记口信息的个数直接维护 i 更简单
    qsort(a, i, sizeof(node), cmp);
    ...
}
```

最后，从左到右、从上到下给排列所有登机口（即树中编号 < 100 的节点）。提到从左到右、从上到下，我们就不禁会想到**树的层次遍历**（如果你没有想到，请参考 `树讲解` 中的 `二叉树的遍历/层次遍历` 部分，我们在此就直接使用写过的代码不做讲解了）：

```c
void bfs(nptr root) {
    enqueue(root);
    int cnt = 0;
    while(!isEmpty()) {
        nptr p = dequeue();
        // 登机口输出
        if(p -> id < 100)
            printf("%d->%d\n", a[cnt++].id, p -> id);
        
        for(int i = 0; i < 3; i++) {
            if(p -> son[i] != NULL)
                enqueue(p -> son[i]);
        }
    }
}
```

在这遇到一个登机口的时候，我们直接按照这个登机口是从左往右、从上到下第几个登记口，输出了对应的在客流量序列表中的登机口了，这样做与你维护好两个列表之后再一一对应输出是等价的。

不难看出这两道题都是非常综合的，利用了 树 + 栈、树 + 队 这样的模式。



## D - 词频统计（树实现）

这道题感觉还比前面两道简单一点。我们每次从文件中获取一个单词，然后将这个单词的出现次数 + 1，最后按字典序输出所有单词及其出现次数。同时，为了让我们用二叉排序树做这道题，他还让我们最后单独输出根节点、根的右儿子，根的右右孙子对应的单词。注意，这个二叉排序树是用于检索之前单词是否出现过，以及单词的出现次数的，所以排序的依据是**单词的字典序**。

首先是从输入中识别单词，即都由字母组成的连续字符串，这又是一个模式匹配问题，我们说过很多遍了，可以用状态转移的思想，请参考**作业讲解-程序设计基础练习-题目讲解**中第五道题的题解；同时这里还有个文件读入，由于除了这个文件读入外后面就没有任何读入了，我们可以用 `freopen` 轻松解决这个问题，关于这一点请参考**作业讲解-第四次作业（栈和队）-题目详解**中第二题的讲解部分，这里我们就直接写了：

```c
char word[105];

int main() {
    freopen("article.txt", "r", stdin);
    char ch;
    int len = 0;
    while((ch = getchar()) != EOF) {
        if(!isalpha(ch)) {
            if(len > 0) {
                // 别忘了手动补空字符，想一想如果不补会有什么后果，可以把这句话删掉运行一下试试
                word[len] = 0;
                insert(word), len = 0;
            }
        } else 
            word[len++] = tolower(ch);
    }
    
    // 如果文件最后以一个字母结尾，上面的循环将不会处理这个字母对应的单词，所以要单独处理一下
    // 你可以把样例文件中最后的 ;" 删掉，再把下面这两行注释掉看看会发生什么错误
    if(len > 0) 
        word[len] = 0, insert(word);
}
```

下面就是 `insert` 的实现。如果插入的单词在树中有对应的结点，那么就把结点的 `cnt` 字段加 1；否则新建一个节点插入树中（新建的结点 `cnt` 初始值为 1）：

```c
// 注意 getnode 的实现有所不同
nptr getnode(char *s) {
    nptr p = newnode();
    // 传入的 s 相当于全局数组 word，后面是会变的，所以自己开空间把内容拷贝一份
    p -> str = (char *)malloc(strlen(s) + 1);
    strcpy(p -> str, s);
    // 初始值应该为 1
    p -> cnt = 1;
    p -> ls = NULL;
    p -> rs = NULL;
    return p;
}

void dfs(nptr p, char *s) {
    // 找到对应的结点，cnt++
    if(strcmp(s, p -> str) == 0) {
        p -> cnt++;
        return ;
    }
    // 小于当前节点
    if(strcmp(s, p -> str) < 0) {
        // 当前节点没有左儿子，那我就放在这
        if(p -> ls == NULL)
            p -> ls = getnode(s);
        // 否则，我去问问你的左儿子
        else
            dfs(p -> ls, s);
    } else {
        if(p -> rs == NULL)
            p -> rs = getnode(s);
        else
            dfs(p -> rs, s);
    }
}

void insert(char *s) {
    // 特殊处理根节点
    if(root == NULL) {
        root = getnode(s);
        return ;
    } 
    dfs(root, s);
}
```

然后输出根、根的右儿子、右儿子的右儿子，要注意的就是特判一下 `p -> rs` 是不是 `NULL`，不然访问 `p -> rs -> rs` 相当于访问空指针，这可以用一个循环去写：

```c
nptr p = root;
len = 0;    // len 再就业
while(p && len < 3)
	printf("%s ", p -> str), p = p -> rs, len++;
```

然后按照字典序输出每个单词和词频，也就相当于从小到大遍历二叉查找树，可以使用中序遍历，原理可以参考**作业讲解-第五次作业-树讲解**中的 `二叉查找树` 部分。简单来说，就是由于对每个子树，它的左子树上的所有结点的值都比根节点小，右子树上的所有结点的值都比根节点大；所以中序遍历对于根节点而言，先输出了所有比它小的，再输出它，再输出所有比它大的；而输出所有比它小的的过程中也有类似的情况，所以最后元素都将升序输出。

```c
void preDfs(nptr p) {
    if(p == NULL)
        return ;
    preDfs(p -> ls);
    printf("%s %d\n", p -> str, p -> cnt);
    preDfs(p -> rs);
}
```



## 实验题 - 树的构造与遍历

简单来说，这道题就是希望我们实现一个 Huffman 树。我们先简要介绍一下背景知识，再进入正题。

### 背景知识

首先，比如我们将文件通过网络传输到其它数字设备时，实际上数字设备只能识别“高电压”和“低电压”，也就是 1 和 0。也就是说，当我们想发送一串文本时（我们这只以英文文本举例），我们就必须先将这串文本转换为一串 01 序列，才能发送过去。

一种显然的做法是将其中每个字符都转换为对应的 ASCII 码二进制表示，然后再发送；这样，每个字符都转换为一个八位的 01 串（或者说 7 位也行，因为字符的 ASCII 值都是正数，符号位都是 0）。当然，一种更好的想法是让出现频率更高的字符编码后尽可能短，出现频率高的字符用更短的二进制编码，出现频率低的字符用稍长一点的编码，这样，就会让整个文本内容编码后的长度尽可能少，避免不必要的浪费，这就是 **Huffman 编码**的出发点。

我们在编码时，还要考虑一个问题，就是**某个字符的编码不能为另一个字符编码的前缀**，比如 `a` 编码为 `1`，`b` 编码为 `10`，那么当我们暂时接收到了一个 `1` 时，我们就不能判断这个 `1` 是表示字符 `a`，还是表示字符 `b` 编码的第一位（即使后面跟着一个 `0` 也不能判断，因为大可以有其它字符的编码以 `0` 开头）。所以，我们希望实现：

- 出现频率高的字符用更短的二进制编码，出现频率低的字符用稍长一点的编码
- 某个字符的编码不能为另一个字符编码的前缀

### Huffman 算法

下面，我们来介绍一下 Huffman 算法的流程，并以 `aaaabbbccd` 的编码为例，走一遍整个流程。

- 首先，先**统计出所有字符的出现次数**：

```
a: 4
b: 3
c: 2
d: 1
```

- **将每个字符变成一棵只有一个结点的树**：

比如对于上面的例子，我们得到四棵仅有一个结点的小树，里面分别存了字符和对应的权重：

```
a(1)   b(2)   c(3)   d(4)
```

- **不断合并权重最低的两个树：**

每次从所有树中，取出根的权重最低的两棵树，设他们的根节点是 $\mathrm{x}$ 和 $\mathrm{y}$。创建一个新的节点 $\mathrm{z}$ 作为新树的根，$\mathrm{z}$ 的左儿子是 $\mathrm{x}$，右儿子是 $\mathrm{y}$，权重为 $\mathrm{x}$ 与 $\mathrm{y}$ 的权重和（这里 $\mathrm{x}$ 和 $\mathrm{y}$ 谁当左儿子谁当右儿子无所谓）。再把 $\mathrm{z}$ 加入树的数组中，重复这一过程，直到数组里只有一个树（其实对于这个数组而言，树和节点是一个意思，说它是树的数组就相当于用根节点代表一棵树）。如果选权重最低的两个结点时由于权重重复有多个选择，随便选就可以。

继续上面的例子，第一次：

```
     (3)
    /   \
  a(1)  b(2) c(3) d(4)
```

第二次：

```
     (6)
    /   \
 c(3)   (3)
       /   \
     a(1)  b(2) d(4)
```

第三次：

```
       (10)
      /    \
   d(4)    (6)
          /   \
       c(3)   (3)
             /   \
          a(1)  b(2)
```

至此，只剩下一棵树了，这一步结束。这棵树就叫做 Huffman 树。

- **利用 Huffman 树进行 Huffman 编码：**

我们先给每条边编号，每个向左的边记作 `0`，向右的边记作 `1`（跟实验保持一致）；然后从根节点出发，到每个字符结点的路径，就是这个字符的 Huffman 编码。

对于我们建出的 Huffman 树：

- a：右右左 $\mathrm{\rightarrow}$ 110
- b：右右右 $\mathrm{\rightarrow}$ 111
- c：右左 $\mathrm{\rightarrow}$ 10
- d：左 $\mathrm{\rightarrow}$ 0

通过这种方式构造出来的编码，称为 Huffman 编码，而且它一定满足我们在背景知识里说过的两个特征。有兴趣的同学可以自行搜索相关证明。

### 回到题目

这次实验，就是已经为我们写好了部分基础代码和测试代码，让我们去实现最为关键的四步。需要注意的一点就是，我们每次只能在下面的部分里添加代码：

```c
//【实验步骤1】开始 

// 我自己新定义了一个函数
void func() {
    
}

void statCount()
{


	
}

//【实验步骤1】结束
```

自己加代码是没问题的，就是没法改除了这四个区域外的任何代码，也就是说比如结点结构体是我们没法改的，我们只能基于他已有的代码写。其实除了四个用于测试的 `print` 其它部分的代码也没多少，而且都很简单，我们直接开始四步实验吧。

**statCount：**

第一步，统计所有字符的出现次数。我们的输入源是文件，而且我们可以看到在主函数里，调用 `statCount` 之前，它已经帮我们打开输入文件指针 `Src` 和输出文件指针 `Obj` 了，只不过 `Obj` 暂时还用不到。统计字符次数也没什么好说的，需要注意的就是 `在该函数中 Ccount[0] 一定要置为 1，即Ccount[0] = 1`，作为压缩文件的结束符，这是题目要求，我们照做就好。同时在说明部分还说了不要处理换行符：

```c
//【实验步骤1】开始 

void statCount()
{
	Ccount[0] = 1;	// 题目要求
	char ch;
	while(( ch = fgetc(Src) ) != EOF) 
		if(ch != '\n')
			Ccount[ch]++;	// 统计字符出现次数
}

//【实验步骤1】结束
```

**createHTree：**

第二步就是创建 Huffman 树了。我们看它给的算法提示，一步一步来。

首先就是为每个出现次数非 0 的字符创建一个单结点树：

```c
typedef struct tnode  node;
typedef struct tnode* nptr;
nptr arr[150];    // 存放 Huffman 树节点的数组
int sz = 0; // 数组大小

nptr newnode() {
    return (nptr)malloc(sizeof(node));
}

nptr getnode(char c, int weight) {
    nptr p = newnode();
    p->c = c;
    p->weight = weight;
    p->left = NULL;
    p->right = NULL;
    return p;
}

void createHTree()
{
    // 创建单结点树
    for(int i=0; i<128; i++)
        if(Ccount[i] > 0) 
            arr[sz++] = getnode(i, Ccount[i]);
    
    // ...
}
```

然后我们就要进行每次取出权重最小的两个结点的操作了。这通常用堆来实现，因为我们只关心最小的是谁，而不关心整体的有序性。但是这里数据规模太小了，所以我们每次重新排序也可以。取出权重最小的两个结点后，合并为一个新节点，再把这个新节点插回到结点数组里。不过，在这个过程中，由于不同结点权重可能相同，为了保证答案唯一，它又额外定义了一些排序规则，总结一下：

- 权重不同的，权重小的在前面。
- 权重相同且两个结点都为字符结点时，字符小的在前面。
- 权重相同且不都为字符节点时，后插入的结点在后面。

也就是说我们写的排序规则要综合考虑权重、字符和插入的时间。但是我们不能修改 `tnode` 结构体，这个结构体里只有权重和字符信息，所以这我使用的一个保存插入时间的处理是这样的：`char` 类型其实是有符号的 $\mathrm{-128 \sim 127}$ 这 256 个数，只不过 ASCII 值都是正的。所以我们可以利用负数部分，比如让第一个后插入结点的 `c` 值为 $\mathrm{-1}$，第二个后插入结点的 `c` 值为 $\mathrm{-2}$，以此类推。

最后为了删除方便，我们把上面的三条排序规则反过来，即变成：

- 权重不同的，权重小的在后面。
- 权重相同且两个结点都为字符结点时，字符小的在后面。
- 权重相同且不都为字符节点时，后插入的结点在前面。

这样做的目的是每次都能取出最后两个结点，就不用移动任何其他元素了。不然你如果每次取出前两个结点的话，你每次都需要把后面的元素向前移动，这样太麻烦了，不如直接把这个规则跟题面反过来，无非也就是换一下 `cmp` 函数返回值谁减谁的事：

```c
int cmp(const void *a, const void *b) {
    nptr x = *(nptr *)a, y = *(nptr *)b;
    // 权重不同，权重小的在后
    if(x -> weight != y -> weight)
        return y -> weight - x -> weight;
    // 权重相同且都是字符结点，字符小的在后
    if(x -> c >= 0 && y -> c >= 0)
        return y -> c - x -> c;
    // 权重相同且不都是非字符结点，后插入的在前
    // c 值越小插入时间越靠后
    return x -> c - y -> c;
}

void createHTree()
{
    ...

    int time = 0;
    while(sz > 1) {
        qsort(arr, sz, sizeof(nptr), cmp);
        nptr left = arr[sz - 1], right = arr[sz - 2];
        // 创建新结点
        nptr p = getnode(--time, left -> weight + right -> weight);
        p -> left = left;
        p -> right = right;
        // 将新结点插入数组
        arr[sz - 2] = p;
        // 移除两个插入一个，总体来看 sz 减小 1
        sz--;
    }

    Root = arr[0]; // 根结点
}
```

**makeHCode：**

依据左边 0 右边 1 的原则，根据根到每个字符的路径，计算出每个字符的 Huffman 编码值。不难看出，在这我们要实现一个遍历树的算法，遍历到某个结点的时候，这个结点能知道根到它的路径的信息，所以我们需要把某个字符串也作为参数，用来记录根到它的路径：

```c
//【实验步骤3】开始

// 用 len 记录从根到 p 经过了几条边
// 即 p 的深度，同时也是 code 的当前长度
void preDfs(nptr p, char *code, int len) {
    // 字符节点一定是叶子结点，因为非前缀性质
    if(p -> left == NULL && p -> right == NULL) {
        code[len] = '\0';
        strcpy(HCode[p -> c], code);
        return;
    }
    // 向左走，设置下一位为 0，记录一条左边
    code[len] = '0';
    preDfs(p -> left, code, len + 1);
    // 向右走，设置下一位为 1，记录一条右边
    code[len] = '1';
    preDfs(p -> right, code, len + 1);
}

void makeHCode()
{
    char code[32];
    preDfs(Root, code, 0); 
} 

//【实验步骤3】结束
```

**atoHZIP：**

最后一步，知道了各个字符的 Huffman 码之后，将原文件中的每个字符转换为它的 Huffman 码（01 串）后输出到输出文件里。输出文件指针 `Obj` 在 `main` 里已经帮我们打开了。

但是这里需要注意的是，输入文件指针里会记录着我们上次读到了哪里，然后当你下次读入的时候它会接着往下读。我们上次使用输入文件指针 `Src` 是在第一步的 `statCount` 里，而且把整个文件读完了，所以现在继续使用 `Src` 我们将不会读到任何东西，我们需要重新打开文件指针。

第二点就是他规定的输出规则，如果你直接输出一串 01 位，那只会得到一堆更长的字符，没有达到压缩的目的。所以应该想办法对这堆 01 位进行压缩，办法就是把这些 01 位 8 个一合并压缩成一个字节，把每个字节按照一个字符进行输出。如果最后一个字节不满八位，就在后面补 0 输出。

第三点就是要手动在 01 串后面补上空字符的编码。

大家可能没看明白什么意思，给大家举个例子，比如现在输入文本是：

```
I wil
```

然后我们假设得到这几个字符的 ASCII 分别是（虽然下面得到的编码值不够合理，但我们只是举个例子，假设前面几步我们都成功完成了）：

```
I：0101111
空格：111
w：1001110
i：01010
l：11001
空字符：1
```

那么从输入文本 `i wil` 得到的 01 串是：

```
010111111110011100101011001
```

手动在后面补上空字符（相当于在上面的 01 串后补上了空字符对应的 01 串编码）：

```
0101111111100111001010110011
```

8 位一分隔：

```
01011111 11100111 00101011 0011
```

最后一个部分不满八位，后面补上 0：

```
01011111 11100111 00101011 00110000
```

然后，对每个八位，按照两位十六进制输出，比如上面的四个八位对应的十六进制表示，可以用如下代码获得：

```c
#include <stdio.h>

void print(unsigned char i) {
    printf("%x", i);
}

int main() {
    print(0b01011111);
    print(0b11100111);
    print(0b00101011);
    print(0b00110000);
}

// 输出 5fe72b30
```

里面用 unsigned char 是因为它是八位无符号数，`0b` 开头表示后面是一个数的二进制表示。

这就是最后一步的大致流程了，我们按照上面说的步骤实现代码：

```c
// 存放二进制串
char binStr[100005];
void atoHZIP()
{
    Src = fopen("input.txt", "r");
    char ch;
    while((ch = fgetc(Src)) != EOF) 
        strcat(binStr, HCode[ch]);
    
    // 手动补空字符
    strcat(binStr, HCode[0]);
    int len = strlen(binStr);
    // 8 的倍数
    if(len % 8 != 0) {
        for(int i = len; i < len + 8 - len % 8; i++)
            binStr[i] = '0';
    }
    
    len = strlen(binStr);
    for(int i = 0; i < len; i += 8) {
        // 8 位二进制转为 1 字节
        unsigned char byte = 0;
        for(int j = 0; j < 8; j++) {
            byte <<= 1;
            if(binStr[i + j] == '1')
                byte |= 1;
        }
        printf("%x", byte);
        // 输出到文件
        fputc(byte, Obj);
    }
}

//【实验步骤4】结束
```

可以看到，在这里我们是用了一个数组 `binStr` 来先把所有字符的二进制串一起放进这里，之后再进行转换处理。但是实际上为了节省空间你也可以读入一个字符就处理一看，看看现在满不满八位，如果满的话就直接输出，这样更省空间。为了方便我们就直接用一个全局数组了。

这就是实验题的全部流程。
