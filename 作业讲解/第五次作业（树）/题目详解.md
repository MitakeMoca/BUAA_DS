<h1 style="text-align: center"> 第四次作业题目详解</h1>

[A - 栈操作](#a------)

[B - C 程序括号匹配检查](#b---c---------)

[C - 计算器](#c------)

[D - 文本编辑模拟操作](#d-----------)

- [字符串](#---)

- [回到题目](#----)

[E - 银行排队模拟](#e---------)

[F - 函数调用关系](#f---------)

* [栈内存](#---)
* [回到题目](#-----1)
* [表](#-)



## A - 栈操作

参考 `栈队讲解` 和 `栈.c` 实现即可，就是一道栈的模板题。

  

## B - C 程序括号匹配检查

这道题有以下几个关键点：

- 文件读入

- 单行注释、多行注释、字符常量、字符串常量中的括号不应该被处理
- 遇到除上述情况及括号外的其它字符，应该直接跳过不管
- 假如说以上三点都处理结束了，从我们的视角来看源程序只有左括号和右括号，那该如何进行匹配？

对于**第一个关键点**，最简单的一个方法就是使用 `freopen`，很多同学对于文件 IO 十分惧怕，因为不知道该如何本地调试。其实文件 IO 相比于正常的控制台输入输出，唯一的区别就变成了输入源输出源变成了文件，其余的地方没有区别。可以参考**选填板子-文件**里的代码，比如我们要从 `in.txt` 读入，那就把 `in.txt` 放在跟源程序一个目录下就可以了。

在进行**最简单的文件读入输出**时，我们通常使用 `freopen`。`freopen` 也就是 `file re open`，文件重定向，只要在主函数一开始写上一行 `freopen("in.txt", "rb", stdin)`（相当于把输入源 stdin 换成了 "in.txt"），那以后的读入代码就什么都不用管了，程序已经把输入从文件取到缓冲区等待我们读取了（如果不理解的话就试着运行一下**选填板子-文件-文件读写_freopen**）。

对于**第二个关键点**，我们其实在之前做过很多次了，遇到这种**字符串模式匹配**的问题，尤其是看到注释的识别，我们就不难想到**状态转移的思想**。如果你还不了解状态转移的思想，可以先去看一下**作业讲解-程序设计基础练习-题目讲解**中第五道题的题解，这里的处理是大同小异的，不过是又多了字符串常量和字符常量，所以在这道题里我们用了以下七个状态：

- 0：普通状态，也就是不在单行注释、多行注释、字符常量、字符串常量中，正常的进行字符读入
- 1：在单行注释里
- 2：在多行注释里，且上一个读到的字符不是 `*`
- 3：在字符串常量里
- 4：在多行注释里，且上一个读到的字符是 `*`
- 5：上一个字符是 `/`（可能要进入单行注释或者多行注释了）
- 6：在字符常量中

作为一个练习，同学们可以试着自己画出这道题的状态转移图。

第三个关键点没什么好说的，直接看第四个关键点。

如果只有左括号 `(`、`{` 和右括号 `)`、`}`，那么该如何进行括号匹配呢？实际上，如果是一个右括号的话，它应该看谁是否跟它匹配？应该是它左面的，第一个还没人匹配的左括号，也就是最后一个进来的且还没有匹配的左括号。如果右括号跟这个左括号匹配，那就会把这个左括号给带走。用一句话概括，就是**左括号入栈，右括号出栈**。

当读入一个左括号时，我们就直接把它加入括号栈（当然题目里还有一个特殊规则，就是如果新进来的左括号是 `{`，此时的栈顶为 `(` 时就应该报错）。当读入一个右括号时，我们查看括号栈栈顶，如果跟这个右括号不匹配，那就报错；如果跟这个右括号匹配，那就让括号栈执行出栈操作。也就是说，括号栈里只可能出现左括号。最后读入完成后，如果括号栈里还有括号，也要报错（这段里的三个报错正好对应了三条规则）。

还有一些其它的细节，比如输出行号什么的，只要我们定义一个结构体和对应结构体类型的栈，在存括号的时候把对应的行号信息存进去就行了（想要维护行号的信息，还要记录一下当前读到了第几行，遇到一个换行符就让这个变量 + 1）。还可以给报错函数封装为一个函数，传入一个结构体根据结构体信息报错，看上去更加简洁。其余细节不过多赘述。

  

## C - 计算器

在读入的这个地方，注意我们不能像**作业讲解-第一次作业-表达式计算**那么读入，因为那道题里一定是`数字 符号 数字 符号 ...` 形式的，但是这道题符号和符号可能挨着。我一开始想这么读入：

```c
while(scanf("%d", &num)) {
    if(num == 0) {
        // 说明是符号
    } else {
        // 说明是数字
    }
}
```

想利用 `scanf` 返回值的技巧进行读入，因为 `scanf` 的返回值相当于成功匹配的元素的个数，比如假如我写的是 `scanf("%d", &num)`，然后输入了一个 `c`，那 `scanf` 就不会改变 `num` 的值，并且返回 `0`。结果发现输出完全不符合我的预期，de 了一会之后发现，`scanf %d` 会读入 `+` 和 `-`，因为它们可能是数字的一部分。比如对上面的代码输入 `1+1`，那它实际上会分别读入 `1` 和 `+1`，并且两次都返回 `1`。

所以这道题的读入大概要这么写：

```c
// 先将所有输入读入为一整个字符串
gets(str);
int i = 0;
while(str[i]) {
    char op = str[i];
    i++;
    // 如果是 = 直接 break 也行，continue 也不影响结果，就是简洁了点
    if(op == ' ' || op == '=')
        continue;
    // isdigit 是 <ctype.h> 里的，用来判断一个字符是不是数字字符
    if(!isdigit(op)) {
        // 进行操作符的处理
    } else {
        // 读入一整个数字
        double num = op - '0';
        while (isdigit(str[i])) {
            num = num * 10 + (str[i] - '0');
            i++;
        }
        // 放进数字栈
        numStk[numTop++] = num;
    }
}
```

读入数字的时候，只需要直接放进数字栈里即可。

读入操作符的时候，我们就要根据操作符的类型进行操作了，有这么几种情况：

- 如果符号栈为空，或者读入的是 `(`，那就直接让读入的操作符进入符号栈即可
- 如果读入的是 `)`，那就一直让符号栈出栈，直到遇到 `(`（其它的谁来也不行）
- 如果读进来的是其它操作符，那就和栈顶比较优先级，如果栈顶符号优先级 $$\mathrm{\ge}$$ 读入的操作符，就让符号栈弹栈，直到栈为空或者栈顶符号操作符 $$\mathrm{\lt}$$ 读入的操作符或者栈顶为 `(`（实际上，只有可能栈顶是 `*`、`/`，或者读进来的操作符是 `+`、`-` 时才会满足这一点，大家可以写一写各种情况理解一下）。

- 如果处理输入串结束后，符号栈不为空，就将符号栈中的符号依次出栈

同时，符号出栈就伴随着从数字栈栈顶弹出两个元素并计算（后出栈的数字 op 先出栈的数字），对于不同的符号，都经过一个相同的流程：

- 弹出第一个数字 a
- 弹出第二个数字 b
- a op b = c
- 将 c 入栈

所以我们可以直接将这个过程封装为一个函数：

```c
void cal(char c) {
    double a = numStk[--numTop];
    double b = numStk[--numTop];
    if(c == '+') numStk[numTop++] = b + a;
    else if(c == '-')   numStk[numTop++] = b - a;
    else if(c == '*')   numStk[numTop++] = b * a;
    else numStk[numTop++] = b / a;
}
```

这样主函数就会相当简单，比如和栈顶比较优先级的部分，就可以这么实现了：

```c
while (opTop > 0 && cmp(opStk[opTop - 1], op)) 
    cal(opStk[--opTop]);
opStk[opTop++] = op;
```

  

## D - 文本编辑模拟操作

我们先来简单回顾一下**字符串**，想要明白这些题里的一些操作，就一定要理解字符串。

### 字符串

字符串并不完全等价于字符数组，二者的关系就像杯子和水一样，字符数组就像杯子（存储字符数据的容器），字符串就像水（需要存在容器里）。字符串是一个**以空字符结尾的字符序列**，这个**空字符用来标记字符串的结束**，但是字符串本身的长度统计并不包括这个空字符。希望同学们一定要记住，**字符串最关键的一点就在于结尾的空字符**。

我们可以通过一个字符数组确定一个字符串，比如字符数组 `str[8]` 中的八个字符分别是 `h e l l o \0 a \0`，其中 `\0` 表示空字符。在这个字符数组中，`hello` 是一个字符串，因为它以空字符结尾。尽管字符数组中还有其他字符（如 `a` 和第二个空字符），但字符串 `str` 实际上指的只有 `hello`。

我们都知道，数组名相当于这个数组的起始地址。当我们想输出一个字符串的时候，我们用 `printf("%s", str)` ，只需要传递字符串的起始地址即可。明明只传进去了一个地址，没有任何关于长度的信息，但 `printf` 函数还是能够正确输出字符串的内容，因为它会从这个地址开始，逐个读取字符，直到遇到空字符（`'\0'`）为止，依赖于空字符界定标识一个字符串的结束，从而确保输出的内容正确。

### 回到题目

简单来看一下题目，题目中包含三种操作：插入、删除和撤销。涉及到撤销操作，所以我们不难联想到这题要使用栈，因为撤销操作满足最近进行的操作先被撤销，也就是后进先出的性质。初始时给出一个初始字符串，和一些已经执行完的操作；然后进行若干次上述操作，进行完这些操作后，输出最后的字符串。

我们先在不考虑占的情况下实现插入和删除操作，插入操作要求在某个指定位置处插入一段字符串，比如在字符串 `a` 的 `pos` 处插入一个字符串 `b`，我们不难想到可以用这样的流程去实现：

- 将 `a` 中 `pos` 处后的字符往后移动到合适的位置（具体来说，每个字符向后移动 `strlen(b)`）
- 用 `b` 覆盖从 `a` 的 `pos` 位置开始的 `strlen(b)` 个字符

比如说，我们想在 `momo` 的位置 $$\mathrm{2}$$ 处（也就是第一个 `o` 后面）插入字符串 `ca`，我们可以：

- 先将原字符串的后两个字符向后移动两位（因为 `ca` 长度为 $$\mathrm{2}$$），原字符串变成 `momomo`（原来的位置不清空也可以，因为一会还会被覆盖掉）
- 然后将 `ca` 放入到字符串的位置 $$\mathrm{2}$$，字符串就变成 `mocamo` 了

我们不难想到利用 `strcpy` 和 `strncpy` 去执行拷贝操作，两者的区别如下：

- `strcpy(a, b)`：将字符串 `b` 克隆到字符串 `a`，然后在后面填一个空字符。
- `strncpy(a, b, n)`：如果 `b` 的长度小于 `n`，那就将 `b` 的所有字符复制到字符串 `a`，然后一直补空字符，直到 `b` 的长度 + 空字符的个数 = n；否则就将 `b` 的前 `n` 个字符拷贝到 `a`，且不添加空字符。

对于上面的第一步（将字符串 `a + pos` 集体向后移动若干位），我们需要使用 `strcpy`，因为之前可能进行过删除操作，导致字符数组后面还有东西，如果不补空字符的话就会出问题，所以我们要使用 `strcpy`（或者手动补空字符）；对于第二步，我们需要使用 `strncpy`，因为我们相当于把 `b` 插在 `a` 的中间，最后的结构是 a 的前半部分 + b + a 的后半部分，如果用 `strcpy` 的话就会在 b 的后面补一个空字符，字符串变成 a 的前半部分 + b，后面的部分就丢失了，导致出错。

但是要注意的是，我们在实现插入函数的时候，不能直接用 `strcpy(a + pos + strlen(b), a + pos)`，C99 标准中规定，如果 `strcpy` 的两个参数代表的字符串有覆盖的话，将会发生未知的问题（希望同学们记住这一点）：

<img src="../../img/4_1.png">

所以我们要新开一个字符串作为媒介，最后实现的插入操作的代码类似于下面：

```c
// 在 str 指定位置插入一个字符串 tem，tem 是一个全局变量，直接在主函数中被读入
void insert(int pos) {
    int len = strlen(tem);
    // 必须引入一个中间字符串
    // 第一步
    char *p = (char *)malloc(strlen(str) + 1);
    strcpy(p, str + pos);
    strcpy(str + pos + len, p);
    // 第二步
    strncpy(str + pos, tem, len);
    free(p);
}
```

删除的代码其实也类似，删除相应的实现在指定的位置处删除指定个数个字符。但是最后还有一个 `undo` 操作，我们不难想到，撤销一个删除操作，就相当于执行一个对应的插入操作；撤销一个插入操作，就相当于执行一个对应的删除操作。由于在删除的时候我们只有位置 + 长度信息，但是在撤销这次删除的时候我们要知道删除的字符串到底是什么，以重新插回去，所以在删除操作的时候也要记录被删掉的字符串（这一点在题面里也有说明），这里我的做法是将被删除的字符串存在一个全局字符数组 `tem` 中：

```c
// 删除 str 指定位置 pos 处的 len 个字符
void del(int pos, int len) {
    int total = strlen(str);
    // 
    if(pos + len > total) 
        len = total - pos;
    
    // 记录下被删除的字符串，以便 undo
    strncpy(tem, str + pos, len);
    tem[len] = 0;
    
    // 必须引入一个中间字符串
    char *p = (char *)malloc(strlen(str) + 1);
    strcpy(p, str + pos + len);
    strcpy(str + pos, p);
    free(p);
}
```

我们维护一个操作栈，对每一次操作我们都记录操作符、位置、插入/删除的字符串三个信息；利用这个操作栈，我们就能够实现 `undo` 操作：

```c
// 撤销一次操作
void undo() {
    if(opTop == 0) 
        return;
    operate op = opStk[--opTop];
    // 撤销插入相当于删除
    if(op.op == 1) 
        del(op.pos, strlen(op.str));
    else if(op.op == 2) {
        // 撤销删除相当于插入，插入 op.str，所以要先将 op.str 拷贝到 tem 上
        strcpy(tem, op.str);
        insert(op.pos);
    }
}
```

  

## E - 银行排队模拟

时隔一年，不得不第三次面对这道特别恶心的题。还记得我大一的时候，每个客户都只被服务一个周期，就是一道单纯的先来先服务了，结果现在每个人服务周期数不同。但是其实这道题最难的地方还是在这个特别费解的题面（不止费解，而且绝对有歧义，歧义产生的原因是题面本身就描述的不准确，也不用苦思冥想到底是怎么回事了，按照我们的理解做上得分、并有所收获就行了）。我们一步一步来看吧。

简单来讲，就是前 $$\mathrm{n}$$ 个周期，每个周期都会来人（这里也就是一个读入的问题）。在每个周期里（注意，这里的周期的范围并不局限在前 $$\mathrm{n}$$ 个周期，而是只要还有人没被服务完就算），有以下几个环节：

- 根据说明 2，周期一开始，会来 $$\mathrm{k}$$ 个人（在 $$\mathrm{n}$$ 周期后可以当成来 $$\mathrm{0}$$ 个人）：

```c
time++;
// 在前 n 个周期中，第 i 个周期来 a[i] 个人，所以等待服务的用户多了 a[i]
wait += a[i];
// 让新来的 a[i] 个人去排队
for(int j = 0; j < a[i]; j++) 
    push(...);
```

- 根据说明 1 跟说明 4，由于来了人，等待的人数增多了，所以我们要动态地增加窗口了：

```c
// wait 表示等待接受服务的总人数，queNum 表示现在的总窗口数
while(wait >= queNum * 7 && queNum < 5)
    queNum++;
```

- 然后，我们在所有在场的用户（注意，这里包括**等待接受服务的用户**和**已经接收了服务但是还没办理完的用户**）中，为前 `queNum` 个到达的用户提供一周期的服务：

```c
// 在 t 时刻为在场的前 queNum 个来的人提供服务
serve(t, queNum);
```

- 提供服务的过程中，可能有一些用户第一次被服务到，它们终于被提供了服务，不在属于**等待接受服务的用户**，所以在 `serve` 中也要动态的维护 `wait` 变量（表示等待接受服务的用户数）
- 提供服务后，一些用户可能在这个周期办理完了业务，它们就要离开银行（也就是说从队伍里离开，不在场了）
- 提供服务后，**等待接受服务的用户**可能减少了（即 `wait` 变量变小了），所以银行要动态减少窗口：

```c
while(wait < queNum * 7 && queNum > 3)
    queNum--;
```

说明 5 其实感觉说的很迷惑，但是简单来说就是 3 个窗口是固定的，剩下那俩窗口在有需要的时候可以扩展，没需要的时候就继续休息，也就是我们上面的两个 `while`。

还有一个容易迷惑同学们的点是**等待接受服务的用户并不等于当前在场的人数**，因为当前在场的人中是有人接受了服务的（比如第一个周期有个人办理复杂业务，那他在第二个周期还在场，但是并不包括在等待接受服务的人数里）。所以我们可以这么维护 `wait` 变量：周期开始时来了 `a[i]` 个人，那 `wait` 就要增加 `a[i]`；在为在场的前 $$\mathrm{queNum}$$ 个人提供服务的过程中，如果发现有人是第一次被提供服务，那说明他才脱离"等待接受服务的用户"，那就让 `wait` 减小 $$\mathrm{1}$$；为了标识每个用户是不是第一次接受服务，我们用 `vis[i]` 表示编号为 $$\mathrm{i}$$ 的用户是否接受过服务。

困惑点讲完了，下面就讲难点了，最大的难点就在 `serve` 函数的实现，就是在队里给前 `queNum` 个人提供服务。由于有的客户可能在这次被服务完后就完成任务，所以我们还要删除，而且要删除的地方可能不是队头，那就要在队中间进行删除了，那就变成一个链表了；而且删除完这个节点后，访问到下一个结点的时候还要特殊处理一下。这样太麻烦了！或者说写一个链表干这样的事就是很麻烦。

那我们有没有什么办法规避掉这样的问题呢？我们思考，为什么我们会感觉麻烦呢，因为我们可能在非队头的位置进行删除。如果我们换个角度，就是让办理完业务的人，留在队伍中不管他，直到他移动到队头的位置再删除掉，这样不就又满足先进先出，就能用一个数组去模拟队实现了吗！这就是 **lazy** 的思想（这个思想真叫 lazy）。具体来说，加入 `lazy` 的 `serve` 流程如下：

- 先检查队头有没有已经结束业务的用户，如果有的话把他们踢出队伍（相当于队头出队）：

```c
while(front <= rear && que[front].service == 0)
    front++;
```

- 然后就可以在剩下的用户中取前 `queNum` 个进行服务了，注意由于中间可能还有一些完成业务的用户留在队伍里（service == 0），那我们就直接跳过他，不为他提供服务，所以这要求我们再增加一个变量记录这一周期已经为多少用户提供服务了：

```c
if(que[tem].service == 0) {
    tem++;
    continue;
}
```

- 不然我们就真的给这个用户提供服务，这个过程里要维护 `wait`、`vis` 跟这一周期已经提供的服务次数：

```c
// 如果他是第一次被服务，那要维护他的等待时间和 wait
if(!vis[que[tem].id]) 
    vis[que[tem].id] = 1, wait--, ans[que[tem].id] = t - que[tem].arrival;
// 他还需要的服务周期减少
que[tem].service--;
// cnt 表示这一周期已经被服务的人数，tem 是下标变量
cnt++, tem++;
```

完成这些后，这道题就算结束了，实现好封装后，主函数的处理也非常简洁：

```c
for(int i = 1; i <= n; i++) {
    time++;
    wait += a[i];
    // 排队
    for(int j = 0; j < a[i]; j++) 
        push(...);
    atTime(time);
}

while(front <= rear) 
    atTime(++time);
```

最后，我反复阅读，还是认为题面里是存在一些歧义的：比如题目里说“一旦有用户去接受服务，银行将根据策略及时减少服务窗口”。在这里我的做法是用户们去接受服务，银行为用户提供一个周期的服务后，再减少窗口，因为我觉得不可能对用户说：“你不用等了，你来服务吧，你不用当等待服务的用户了”；又在人家刚要起身的时候说因为你要去了，所以窗口减少了，你在这等吧，但是我不算你是等待服务的用户了，这种事情实在太滑稽了（但是一个学弟跟我说他按只要有人准备去服务，不管我真没真给他提供服务度，都把他从等待的人里扣除出去，这么去做也过了）。

又比如根据说明 4，应该这么维护等待被服务的人数：只要有用户是第一次接受服务，就应该把等待的人数 -1；然后只有每一周期开始，才会增加这个等待人数，就是这一周期新来的人数。但是我们考虑这么一种情况：假如第一周期来了 32 个人，每人办理三周期；以后都不来人。那一开始有 5 个窗口，5 个人去接受服务，所以剩下的等待接受服务的人就变成了 27 个；所以，下一个周期一开始一看，等待服务的人只有 27 个，就只有四个窗口了，那我去的 5 个人就有一个这一回合不能接受服务了；那他会被重新计算到等待接受服务的人吗（这将影响这一回合的窗口数）？我的实现就是照题面说的，不重新看了，就当他不属于等待接受服务的人了。

还有这道题感觉没法细想哪个人站在哪个窗口，不然窗口减少的时候，一个人以前在对公窗口正在办理业务，结果对公窗口没了，那他还要插队去另一个对私窗口去办？实在没法细想，我的建议是直接假设只有一个队，如果这次开放 $$\mathrm{k}$$ 个窗口，就只是单纯地为队伍的前 $$\mathrm{k}$$ 个人提供服务。

我反复阅读，认为这几点确实都是题面里没有说清楚的。我觉得大家也不用细扣这了，因为对着这些含糊不清的说明去试图猜他到底是什么意思是没有意义的，最重要的是锻炼我们自己设计与编码实现的能力，只要聚焦于这一点就好了。



## F - 函数调用关系

### 栈内存

首先我们引申这道题的一些背景知识，这部分跳过也可以（直接去**回到题目**这一节）：

- 函数在调用时需要分配一块空间来保存局部变量、返回地址等。所以我们要提供一个大的内存空间，当由于函数调用，需要分配一块空间时，我们就从这个大的内存空间里选出合适的一块空间分配出去。换句话说，在这个大的内存数组上，我们需要实现一个内存分配策略，以响应指定大小的空间申请。
- 由于函数调用满足后进先出，即最后被调用的函数最先被返回。所以为函数调用分配出去的空间，也满足最后分配出去的空间最先被回收（函数返回时，空间被回收），所以上一部分提到的大的内存空间，可以使用一个简单的内存分配策略——栈式内存分配策略。这个大的内存空间，也被称为栈内存。

举例来说，假设有下面的一段代码：

```c
void A() {}
void B() {A();}
void C() {}

int main() {
    B();
    C();
}
```

- 程序启动时，调用 `main`，在栈内存上为 `main` 函数的调用分配指定大小的空间（被分配出去的空间称为一个**栈帧**），栈空间如下所示：

```
+--------------------------+
| main 的栈帧               |
+--------------------------+
```

- `main` 调用 `B`：

```
+--------------------------+
| B 的栈帧                  |
+--------------------------+
| main 的栈帧               |
+--------------------------+
```

- `B` 调用 `A`：

```
+--------------------------+
| A 的栈帧                  |
+--------------------------+
| B 的栈帧                  |
+--------------------------+
| main 的栈帧               |
+--------------------------+
```

- `A` 执行完毕并返回：

```
+--------------------------+
| B 的栈帧                  |
+--------------------------+
| main 的栈帧               |
+--------------------------+
```

- `B` 执行完毕并返回：

```
+--------------------------+
| main 的栈帧               |
+--------------------------+
```

- `main` 调用 `C`：

```
+--------------------------+
| C 的栈帧                  |
+--------------------------+
| main 的栈帧               |
+--------------------------+
```

- `C` 执行完毕并返回：

```
+--------------------------+
| main 的栈帧               |
+--------------------------+
```

- 最后，`main` 执行完毕

以上就是一个函数调用过程中，栈空间的变化情况。

### 回到题目

通过上面的一个例子，追踪一次函数调用过程中栈空间的状态，我们可以发现一个规律：除了 `main` 函数外，其他函数都是被另一个函数调用的。如果函数 `B` 入栈前栈空间的栈顶为 `A`，则函数 `B` 被 `A` 调用一次。也就是题面中所说的**当一个函数入栈时，它就是当前栈顶函数调用的一个函数**。

了解这个背景后，可以发现这道题下面两个实现关键点：

- 需要按照**运行时调用先后顺序**输出函数调用关系
- 需要记录所有函数调用过其它哪些函数

对于第一个关键点，简单来说，就是给所有出现过的函数排一个序，出现时间越早的函数越靠前。我们可以维护一个数组 `func`，`func[0]` 表示第一个出现的函数、`func[1]` 表示第二个出现的函数$\cdots$。每次遇到一个新函数时，我们检查它是否已经存在于 `func` 数组中。如果不存在，说明这是该函数第一次被调用，我们将它添加到 `func` 数组的末尾。最后 `func` **数组中的顺序**，就是**函数第一次被调用的顺序**。

同时，我们还自然地建立了一个从函数名到整数的映射关系。例如，如果 `func[0]` 是 `main`，那么函数名 `main` 就被映射为整数 `0`。

```c
int find(char *s) {
    // 如果一个函数名之前有出现过，那么返回它的编号
    for(int i = 0; i < total; i++) 
        if(strcmp(func[i], s) == 0) 
            return i;
    
    // 否则，将它插在 func 数组的末尾，并返回它的编号
    func[total] = (char *)malloc(strlen(s) + 1);
    strcpy(func[total], s);
    return total++;
}
```

为了实现记录每个函数调用过其它哪些函数，我们可以利用上面的函数名到整数的映射关系。使用一个二维数组 `calls`，其中 `calls[i]` 表示 `func[i]` 调用过的函数列表。

假如说我们定义 `calls[10][10]`，但是实际上 `func[1]` 只调用过一个函数，那么必须要标记 `calls[1]` 中剩下的部分是无效的。这里有两种实现方法，一种是将 `func` 数组从 $1$ 开始记录，也就是函数从 $1$ 开始编号，这样后面无效的部分一定都是 $0$，而且函数的编号都不是 $0$，就能区分出无效的部分了；另一种是，可以再开一个 `len` 数组，`len[i]` 表示 `calls[i]` 的有效长度（即 `func[i]` 调用过几个不同的函数），这种方法的优点是易于实现**若一个函数没有调用其它函数，则不输出调用关系**这个需求。

最后，还要注意**在一个函数中，同一函数有可能被调用多次，输出调用关系时只输出一次**。为此，我们可以维护一个 `vis` 数组，`vis[i][j]` 表示函数 `func[i]` 是否调用过 `func[j]`；或者每次查找 `calls[i]` 中是否存在过 `j`。

### 表

这部分作为扩展知识可以跳过。

我们不难发现，我们定义了一个二维数组 `calls[][]`，但是其实这样定义大量的空间被浪费掉了。比如定义了一个 `calls[10][10]`，但是实际上 `func[1]` 只调用过一个函数，那 `func[1][1]` $$\mathrm{\sim}$$ `func[1][9]` 这部分空间就被浪费掉了。

我们可以想到之前遇到过这样的问题，就是在上学期的程设中，记录若干只水獭的名字。水獭有 $$\mathrm{10000}$$ 只，水獭名字最长是 $$\mathrm{100}$$，但是保证所有水獭的名字长度加在一起一定不超过 $$\mathrm{500000}$$，如果我们还用一个二维数组的话，就要定义 `char name[10000][100]`，很多空间就被浪费掉了，所以我们就需要定义一个指针数组 `char *name[10000]`，为每个 `char[i]` 动态地申请空间，这样就不会产生空间的浪费了。

同理，在上面的例子中也可以动态地定义 `calls[i]` 为一条链，当 `func[i]` 新调用了一个函数 `func[j]` 时就动态地创建一个值为 `j` 的结点，插入到链 `calls[i]` 中。也就是说，`calls` 相当于一个**链表的数组**（是一个数组，数组中每一个元素是一个链表的起始节点）。这种数据结构称为**表（Table）**（实际上不完全准确，表的各行之间也可以用链表连接），我们后面也会学到哈希表、图中的临接表等，都可以这么实现。



## G - Web 浏览

