<h1 style="text-align: center"> 第五次作业题目详解</h1>

[A - 树叶结点遍历](#a------)

[B - 计算器（表达式树实现）](#b---c---------)



## A - 树叶结点遍历

请先参考 `树讲解`。这道题在正常的二叉查找树的基础上，增加了两点：每个节点增加了一个高度信息；最后从左到右输出所有的叶子结点。

我们在 `树讲解` 中讲过节点插入的流程，大致按照如下递归实现：

```c
void insert(nptr p, int val) {
    if(val < p -> val) {
        if(p -> ls == NULL) {
            p -> ls = getnode(val, p -> dep + 1);
            return;
        } else
            insert(p -> ls, val);
    } else {
        if(p -> rs == NULL) {
            p -> rs = getnode(val, p -> dep + 1);
            return;
        } else
            insert(p -> rs, val);
    }
}

int main() {
    ...
    for(int i = 1; i <= n; i++) {
        if(root == NULL) {
            root = getnode(readInt(), 1);
            continue;
        } else
            insert(root, readInt());
    }
    ...
}
```

可以看到，在插入对应结点的时候，我们把它的高度设置为它要插入的父节点的高度 + 1，这样就能够在插入过程中自动地维护所有结点的高度了。

对于从左到右输出所有的叶子结点，我们可以使用中序遍历，遇到叶子节点的时候再输出（叶子结点的判断条件就是左右孩子都是 NULL）：

```c
void inDfs(nptr p) {
    if(p == NULL) return;
    inDfs(p -> ls);
    if (p -> ls == NULL && p -> rs == NULL)
        printf("%d %d\n", p -> val, p -> dep);
    inDfs(p -> rs);
}

int main() {
    ...
    inDfs(root);
    return 0;
}
```

其实这不管使用前序遍历、中序遍历还是后序遍历都可以，因为在这三种遍历里都是先访问左子树再访问右子树，所以一定都是从左到右输出叶子节点。

  

## B - 计算器（表示式树实现）

又是我们的老朋友表达式计算，不过这题希望我们：输入字符串，表示中缀表达式 $\mathrm{\rightarrow}$ 后缀表达式 $\mathrm{\rightarrow}$ 表达式树 $\mathrm{\rightarrow}$ 算出表达式。为了强迫我们使用表达式树，它最后还让我们输出表达式树的根和左儿子右儿子。

我们再来回顾一下中缀表达式转后缀表达式吧。首先我们假设有两种结点，分别是数字结点和操作符结点，但是我们只用一个结构体来实现，用 `type` 字段标识是数字结点还是操作符结点，如下：

```c
struct node {
	int type;	// 0 表示数字结点，1 表示操作符结点
    int num;	// type = 0 时，表示操作数
    char op;	// type = 1 时，表示操作符
    nptr ls, rs;	// 留给后面建树用
}
```

读入一个非空格、非等号字符时，创建一个字符结点；读入一个数字字符时，一直读入，直到不是数字，创建一个数字结点。

然后就是将字符结点和数字结点推入栈中时的各种规则了，我们只在这回顾一下规则，省得大家去翻了（注意，下面的`输出`是指放到表示后缀表达式的结点数组里）：

- 数字节点直接输出
- `(` 结点直接入符号栈
- 遇到 `)` 结点一直符号栈一直出栈并输出，直到遇到一个 `(` 结点，把这个 `(` 结点也出栈（但是不输出）
- 其余的操作符结点，一直出栈并输出，直到栈为空、栈顶为 `(` 或者栈顶为符号且优先级比新来的操作符低。最后将这个操作符结点入栈
- 直到输入结束，如果符号栈中还有结点，直接输出

总结来说，中缀转后缀的代码大概就是这样：

```c
nptr stack[105], post[105];
int top = -1, cnt = 0;

void push(nptr p) {
    stack[++top] = p;
}

nptr pop() {
    return stack[top--];
}

int pre(char op) {
    switch (op) {
        case '+':
        case '-':
            return 1;
        case '*':
        case '/':
            return 2;
        case '(':
            return 0;
        default:
            return -1;
    }
}

void build_post() {
    int len = strlen(str);
    for(int i = 0; i < len; i++) {
        if(isdigit(str[i])) {
            int num = 0;
            while(isdigit(str[i])) {
                num = num * 10 + str[i] - '0';
                i++;
            }
            nptr p = getnode(0, num, 0);
            post[cnt++] = p;
            // 此时 str[i] 一定不是数字，由此保证有没有进入到这个分支，交给下面分支的都是一个字符
        }
        if(str[i] == ' ')
            continue;
        if(str[i] == '=')
            break;
        if (str[i] == '(') {
            push(getnode(1, 0, str[i]));
        } else if (str[i] == ')') {
            while (top != -1 && stack[top] -> op != '(') {
                post[cnt++] = pop();
            }
            pop();
        } else {  // 处理操作符
            while (top != -1 && pre(stack[top] -> op) >= pre(str[i])) 
                post[cnt++] = pop();
            push(getnode(1, 0, str[i]));
        }
    }

    while(top != -1) {
        post[cnt++] = pop();
    }
}
```

上面的代码段运行结束后，`post` 里存的就是原输入字符串代表的中缀表达式形成的后缀表达式了。下面就按照题目中给出的由后缀表达式建立表达式树的方法来建立表达式树。可以看到该流程中又需要用到一个栈，我们将原来用于中缀转后缀的 `stack` 复用即可（注意在 `build_post` 里，我们最后将栈清空了，此时 `top = -1`，所以我们直接用这个栈即可，不需要做其他任何初始化操作）：

```c
void build_tree() {
    for(int i = 0; i < cnt; i++) {
        // 是数字，直接建立单节点树并入栈，单节点树就相当于带 ls、rs 字段的结点
        if(post[i] -> type == 0) {
            stack[++top] = post[i];
        } else {
            post[i] -> rs = pop();
            post[i] -> ls = pop();
            stack[++top] = post[i];
        }
    }
}
```

上面的操作结束以后，`stack` 中一定只有一个结点，也就是 `stack[0]`，它也就是表达式树的树根。

输出树根、左儿子、右儿子，写一个能传入结点的函数即可：

```c
void printNode(nptr p) {
    if(p == NULL)
        return ;
    if(p -> type == 0)
        printf("%d ", p -> num);
    else 
        printf("%c ", p -> op);
}
```

最后就是利用表达式树计算表达式的过程了，其实对于每个叶子结点，它都是一个操作数，那么它的值就是该数本身；对于每个非叶节点 `op`，它的值就相当于 `左儿子的值 op 右儿子的值`，所以在计算出这个结点的值之前，需要计算出它的左儿子和右儿子的值，所以我们需要使用后序遍历方式：

```c
void postDfs(nptr p) {
    // 递归边界一定是叶子结点，不用考虑空节点了
    // 因为非叶子结点一定有两个儿子，因为这些操作符必须都要有两个操作数
    if(p -> type == 0)
        return ;
    postDfs(p -> ls);
    postDfs(p -> rs);
    p -> num = cal(p -> op, p -> ls -> num, p -> rs -> num);
}
```
