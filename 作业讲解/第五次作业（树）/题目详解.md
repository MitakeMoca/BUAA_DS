<h1 style="text-align: center"> 第五次作业题目详解</h1>

[A - 树叶结点遍历](#a------)

[B - 计算器（表达式树实现）](#b---c---------)

[C - 服务优化](#c------)

[D - 词频统计（树实现）](#d-----------)

[实验 - 树的构造与遍历](#e---------)

## A - 树叶结点遍历

请先参考 `树讲解`。这道题在正常的二叉查找树的基础上，增加了两点：每个节点增加了一个高度信息；最后从左到右输出所有的叶子结点。

我们在 `树讲解` 中讲过节点插入的流程，大致按照如下递归实现：

```c
void insert(nptr p, int val) {
    if(val < p -> val) {
        if(p -> ls == NULL) {
            p -> ls = getnode(val, p -> dep + 1);
            return;
        } else
            insert(p -> ls, val);
    } else {
        if(p -> rs == NULL) {
            p -> rs = getnode(val, p -> dep + 1);
            return;
        } else
            insert(p -> rs, val);
    }
}

int main() {
    ...
    for(int i = 1; i <= n; i++) {
        if(root == NULL) {
            root = getnode(readInt(), 1);
            continue;
        } else
            insert(root, readInt());
    }
    ...
}
```

可以看到，在插入对应结点的时候，我们把它的高度设置为它要插入的父节点的高度 + 1，这样就能够在插入过程中自动地维护所有结点的高度了。

对于从左到右输出所有的叶子结点，我们可以使用中序遍历，遇到叶子节点的时候再输出（叶子结点的判断条件就是左右孩子都是 NULL）：

```c
void inDfs(nptr p) {
    if(p == NULL) return;
    inDfs(p -> ls);
    if (p -> ls == NULL && p -> rs == NULL)
        printf("%d %d\n", p -> val, p -> dep);
    inDfs(p -> rs);
}

int main() {
    ...
    inDfs(root);
    return 0;
}
```

其实这不管使用前序遍历、中序遍历还是后序遍历都可以，因为在这三种遍历里都是先访问左子树再访问右子树，所以一定都是从左到右输出叶子节点。

  

## B - 计算器（表示式树实现）

又是我们的老朋友表达式计算，不过这题希望我们：输入字符串，表示中缀表达式 $\mathrm{\rightarrow}$ 后缀表达式 $\mathrm{\rightarrow}$ 表达式树 $\mathrm{\rightarrow}$ 算出表达式。为了强迫我们使用表达式树，它最后还让我们输出表达式树的根和左儿子右儿子。

我们再来回顾一下中缀表达式转后缀表达式吧。首先我们假设有两种结点，分别是数字结点和操作符结点，但是我们只用一个结构体来实现，用 `type` 字段标识是数字结点还是操作符结点，如下：

```c
struct node {
	int type;	// 0 表示数字结点，1 表示操作符结点
    int num;	// type = 0 时，表示操作数
    char op;	// type = 1 时，表示操作符
    nptr ls, rs;	// 留给后面建树用
}
```

读入一个非空格、非等号字符时，创建一个字符结点；读入一个数字字符时，一直读入，直到不是数字，创建一个数字结点。

然后就是将字符结点和数字结点推入栈中时的各种规则了，我们只在这回顾一下规则，省得大家去翻了（注意，下面的`输出`是指放到表示后缀表达式的结点数组里）：

- 数字节点直接输出
- `(` 结点直接入符号栈
- 遇到 `)` 结点一直符号栈一直出栈并输出，直到遇到一个 `(` 结点，把这个 `(` 结点也出栈（但是不输出）
- 其余的操作符结点，一直出栈并输出，直到栈为空、栈顶为 `(` 或者栈顶为符号且优先级比新来的操作符低。最后将这个操作符结点入栈
- 直到输入结束，如果符号栈中还有结点，直接输出

总结来说，中缀转后缀的代码大概就是这样：

```c
nptr stack[105], post[105];
int top = -1, cnt = 0;

void push(nptr p) {
    stack[++top] = p;
}

nptr pop() {
    return stack[top--];
}

int pre(char op) {
    switch (op) {
        case '+':
        case '-':
            return 1;
        case '*':
        case '/':
            return 2;
        case '(':
            return 0;
        default:
            return -1;
    }
}

void build_post() {
    int len = strlen(str);
    for(int i = 0; i < len; i++) {
        if(isdigit(str[i])) {
            int num = 0;
            while(isdigit(str[i])) {
                num = num * 10 + str[i] - '0';
                i++;
            }
            nptr p = getnode(0, num, 0);
            post[cnt++] = p;
            // 此时 str[i] 一定不是数字，由此保证有没有进入到这个分支，交给下面分支的都是一个字符
        }
        if(str[i] == ' ')
            continue;
        if(str[i] == '=')
            break;
        if (str[i] == '(') {
            push(getnode(1, 0, str[i]));
        } else if (str[i] == ')') {
            while (top != -1 && stack[top] -> op != '(') {
                post[cnt++] = pop();
            }
            pop();
        } else {  // 处理操作符
            while (top != -1 && pre(stack[top] -> op) >= pre(str[i])) 
                post[cnt++] = pop();
            push(getnode(1, 0, str[i]));
        }
    }

    while(top != -1) {
        post[cnt++] = pop();
    }
}
```

上面的代码段运行结束后，`post` 里存的就是原输入字符串代表的中缀表达式形成的后缀表达式了。下面就按照题目中给出的由后缀表达式建立表达式树的方法来建立表达式树。可以看到该流程中又需要用到一个栈，我们将原来用于中缀转后缀的 `stack` 复用即可（注意在 `build_post` 里，我们最后将栈清空了，此时 `top = -1`，所以我们直接用这个栈即可，不需要做其他任何初始化操作）：

```c
void build_tree() {
    for(int i = 0; i < cnt; i++) {
        // 是数字，直接建立单节点树并入栈，单节点树就相当于带 ls、rs 字段的结点
        if(post[i] -> type == 0) {
            stack[++top] = post[i];
        } else {
            post[i] -> rs = pop();
            post[i] -> ls = pop();
            stack[++top] = post[i];
        }
    }
}
```

上面的操作结束以后，`stack` 中一定只有一个结点，也就是 `stack[0]`，它也就是表达式树的树根。

输出树根、左儿子、右儿子，写一个能传入结点的函数即可：

```c
void printNode(nptr p) {
    if(p == NULL)
        return ;
    if(p -> type == 0)
        printf("%d ", p -> num);
    else 
        printf("%c ", p -> op);
}
```

最后就是利用表达式树计算表达式的过程了，其实对于每个叶子结点，它都是一个操作数，那么它的值就是该数本身；对于每个非叶节点 `op`，它的值就相当于 `左儿子的值 op 右儿子的值`，所以在计算出这个结点的值之前，需要计算出它的左儿子和右儿子的值，所以我们需要使用后序遍历方式：

```c
void postDfs(nptr p) {
    // 递归边界一定是叶子结点，不用考虑空节点了
    // 因为非叶子结点一定有两个儿子，因为这些操作符必须都要有两个操作数
    if(p -> type == 0)
        return ;
    postDfs(p -> ls);
    postDfs(p -> rs);
    p -> num = cal(p -> op, p -> ls -> num, p -> rs -> num);
}
```



## C - 服务优化

这题看上去挺唬人的，不过请仔细读题理解一下他到底要你干啥。

首先输入一棵三叉树，所有 < 100 的结点叫登机口，而且一定是叶子结点。然后输入这些登机口原来的客流量；显然我们希望客流量越高的地方离安检处越近，这样大伙普遍就能走的更少了。所以我们先给这些结点按客流量从高到低排个序。原来的这些登机口，我们把它们从左到右、从上到下都拿出来，然后把它们按照客流量顺序安排成新的登机口，再输出一个`原来登机口 -> 新登机口` 信息。

所以，总结来说就是最后有两个列表，第一个列表是从左到右、从上到下，按照树结构来排列登机口；第二个列表是按照客流量（客流量相等时按编号）排列登机口。这俩列表中的登机口按照位置有一一对应的关系。

首先是创建三叉树，我们想从链表到二叉树，由最多一个后继变为了最多两个，我们就增加了一个指针域；现在无非是变成了三个，所以我们定义结点结构如下：

```c
struct node {
    int id, num;
    // 这里用了一个数组，方便后面依次添加儿子
    // 如果用 ls、ms、rs 这种写法要加很多特判
    nptr son[3];
};
```

这棵树的根题目里保证了一定为 `100`，所以我们可以先建根：

```c
nptr root = getnode(100);	// 写在主函数里，因为全局变量不允许编译时未知的值，而 malloc 分配的空间是运行时才可知的
```

然后，每次先读入一个已有的结点，再读入它的三个儿子，以此来创建树：

```c
nptr p;
void find(nptr q, int n) {
    if(q == NULL)
        return ;
    if(q -> id == n) {
        p = q;
        return ;
    }
    for(int i = 0; i < 3; i++) 
        find(q -> son[i], n);
}

int main() {
    ...
    int n;
    while((n = readInt()) != -1) {
        find(root, n);
        // find 之后，p 就是当前结点
        int m, cnt = 0;
        while((m = readInt()) != -1) {
            nptr q = getnode(m);
            p -> son[cnt++] = q;
        }
    }
}
```

这里有两个关键点：第一是查找已有结点的操作，如果你不理解为什么我一定要像上面那样写的话，请先参考 `树讲解` 里的 `二叉查找树查找操作容易犯的一个 bug` 部分；第二就是在给已有结点添加孩子的过程中，我们就从左往右添加就可以，不用像题目图里的 `110` 号结点一样，有两个孩子好像放在了 `son[0]` 和 `son[2]` 的位置，这样的好处是我们不用每次特判需要放在哪，直接往上填就行了。

建树过程完毕，第二步读入每个登机口的客流量，并给他们排序。这的操作其实很简单，我们为了方便在这里新开了一个 `node` 数组（而不是 `nptr` 数组），然后直接排序就可以了：

```c
int cmp(const void *a, const void *b) {
    node *x = (node *)a;
    node *y = (node *)b;
    if(x -> num == y -> num)
        return x -> id - y -> id;
    return y -> num - x -> num;
}

int main() {
    ...
    int id, num, i = 0;
    // 不定组输入，结束输入用 ctrl + z
    // 你也可以提前维护有几个登机口，来变成定组输入
    while(scanf("%d %d", &id, &num) != EOF) {
        a[i].id = id, a[i].num = num;
        i++;
    }
	// 这里 i 保存了有几个登记口，你也可以通过查找树上有几个 id < 100 的结点来维护 i
    // 不过显然通过读入登记口信息的个数直接维护 i 更简单
    qsort(a, i, sizeof(node), cmp);
    ...
}
```

最后，从左到右、从上到下给排列所有登机口（即树中编号 < 100 的节点）。提到从左到右、从上到下，我们就不禁会想到**树的层次遍历**（如果你没有想到，请参考 `树讲解` 中的 `二叉树的遍历/层次遍历` 部分，我们在此就直接使用写过的代码不做讲解了）：

```c
void bfs(nptr root) {
    enqueue(root);
    int cnt = 0;
    while(!isEmpty()) {
        nptr p = dequeue();
        // 登机口输出
        if(p -> id < 100)
            printf("%d->%d\n", a[cnt++].id, p -> id);
        
        for(int i = 0; i < 3; i++) {
            if(p -> son[i] != NULL)
                enqueue(p -> son[i]);
        }
    }
}
```

在这遇到一个登机口的时候，我们直接按照这个登机口是从左往右、从上到下第几个登记口，输出了对应的在客流量序列表中的登机口了，这样做与你维护好两个列表之后再一一对应输出是等价的。

不难看出这两道题都是非常综合的，利用了 树 + 栈、树 + 队 这样的模式。



## D - 词频统计（树实现）

这道题感觉还比前面两道简单一点。我们每次从文件中获取一个单词，然后将这个单词的出现次数 + 1，最后按字典序输出所有单词及其出现次数。同时，为了让我们用二叉排序树做这道题，他还让我们最后单独输出根节点、根的右儿子，根的右右孙子对应的单词。注意，这个二叉排序树是用于检索之前单词是否出现过，以及单词的出现次数的，所以排序的依据是**单词的字典序**。

首先是从输入中识别单词，即都由字母组成的连续字符串，这又是一个模式匹配问题，我们说过很多遍了，可以用状态转移的思想，请参考**作业讲解-程序设计基础练习-题目讲解**中第五道题的题解；同时这里还有个文件读入，由于除了这个文件读入外后面就没有任何读入了，我们可以用 `freopen` 轻松解决这个问题，关于这一点请参考**作业讲解-第四次作业（栈和队）-题目详解**中第二题的讲解部分，这里我们就直接写了：

```c
char word[105];

int main() {
    freopen("article.txt", "r", stdin);
    char ch;
    int len = 0;
    while((ch = getchar()) != EOF) {
        if(!isalpha(ch)) {
            if(len > 0) {
                // 别忘了手动补空字符，想一想如果不补会有什么后果，可以把这句话删掉运行一下试试
                word[len] = 0;
                insert(word), len = 0;
            }
        } else 
            word[len++] = tolower(ch);
    }
    
    // 如果文件最后以一个字母结尾，上面的循环将不会处理这个字母对应的单词，所以要单独处理一下
    // 你可以把样例文件中最后的 ;" 删掉，再把下面这两行注释掉看看会发生什么错误
    if(len > 0) 
        word[len] = 0, insert(word);
}
```

下面就是 `insert` 的实现。如果插入的单词在树中有对应的结点，那么就把结点的 `cnt` 字段加 1；否则新建一个节点插入树中（新建的结点 `cnt` 初始值为 1）：

```c
// 注意 getnode 的实现有所不同
nptr getnode(char *s) {
    nptr p = newnode();
    // 传入的 s 相当于全局数组 word，后面是会变的，所以自己开空间把内容拷贝一份
    p -> str = (char *)malloc(strlen(s) + 1);
    strcpy(p -> str, s);
    // 初始值应该为 1
    p -> cnt = 1;
    p -> ls = NULL;
    p -> rs = NULL;
    return p;
}

void dfs(nptr p, char *s) {
    // 找到对应的结点，cnt++
    if(strcmp(s, p -> str) == 0) {
        p -> cnt++;
        return ;
    }
    // 小于当前节点
    if(strcmp(s, p -> str) < 0) {
        // 当前节点没有左儿子，那我就放在这
        if(p -> ls == NULL)
            p -> ls = getnode(s);
        // 否则，我去问问你的左儿子
        else
            dfs(p -> ls, s);
    } else {
        if(p -> rs == NULL)
            p -> rs = getnode(s);
        else
            dfs(p -> rs, s);
    }
}

void insert(char *s) {
    // 特殊处理根节点
    if(root == NULL) {
        root = getnode(s);
        return ;
    } 
    dfs(root, s);
}
```

然后输出根、根的右儿子、右儿子的右儿子，要注意的就是特判一下 `p -> rs` 是不是 `NULL`，不然访问 `p -> rs -> rs` 相当于访问空指针，这可以用一个循环去写：

```c
nptr p = root;
len = 0;    // len 再就业
while(p && len < 3)
	printf("%s ", p -> str), p = p -> rs, len++;
```

然后按照字典序输出每个单词和词频，也就相当于从小到大遍历二叉查找树，可以使用中序遍历，原理可以参考**作业讲解-第五次作业-树讲解**中的 `二叉查找树` 部分。简单来说，就是由于对每个子树，它的左子树上的所有结点的值都比根节点小，右子树上的所有结点的值都比根节点大；所以中序遍历对于根节点而言，先输出了所有比它小的，再输出它，再输出所有比它大的；而输出所有比它小的的过程中也有类似的情况，所以最后元素都将升序输出。

```c
void preDfs(nptr p) {
    if(p == NULL)
        return ;
    preDfs(p -> ls);
    printf("%s %d\n", p -> str, p -> cnt);
    preDfs(p -> rs);
}
```



## 实验题 - 树的构造与遍历

