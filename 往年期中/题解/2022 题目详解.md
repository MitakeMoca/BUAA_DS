<h1 style="text-align: center"> 2022 年期中题目详解

## 选择题

所有选择题都在 2020 期中也考过。

1.首先，在 `int *point, a = 4;` 语句中，定义了一个 `int` 类型的指针和一个 `int` 变量 `a`。在 `point = &a;` 中将 `point` 的值设成了变量 `a` 的地址。

然后介绍一下 C 语言中 `*` 和 `&` 符号的作用：

- `&`：逻辑运算符（按位与）；取地址符，`&a` 获得变量 `a` 的起始地址
- `*`：乘号；定义某一类型的指针，`int *point` 表示定义一个 `int` 类型的指针 `point`；解引用，如 `*point`，即从 `point` 指向的地址开始，取出四个字节，按照一个 `int` 来解释，获得一个 `int`（也就是给我一个地址，得到一个值）

可以看到，取地址和解引用是互逆的，即 `*(&a) = &(*a) = a`（虽然对于 int 变量 `a` 而言 `*a` 没有实际意义甚至是非法的，但是也符合语法，只是在逻辑上不对）。所以四个选项中：

- a（值）、point（地址）、*&a（值，相当于 a）
- &(\*a)（值，相当于 a）、&a（地址）、\*point（值，相当于 a）
- \*(&point)（地址，相当于 point）、*point（值）、&a（地址）
- &a（地址）、&(*point)（地址）、point（地址）

$\newline$

2.理解 `->` 运算符的作用，`->` 运算符实际上是一个简写形式，`p -> x` 等价于 `(*p).x`，也就是先解引用，再取出某字段。  

A 正确，直接通过结构变量，利用 `.` 运算符取出某结构成员。  

B 正确，利用某结构类型的指针变量，利用 `->` 运算符取出结构成员。  

C 正确，(*p) 相当于先获得某结构变量，再用 `.` 运算符取出某结构成员。  

D 不正确，因为 `.` 的优先级比 `*` 的优先级更高，所以会先执行 `p.x`，但是 `p` 是个指针，所以错误。  

$\newline$

3.参考`选择题-7`，选 D。  

$\newline$

4.只要提到循环链表，一定要知道一个关系：**尾结点的后继元素是头结点**。所以一定正确的选项是 A。

$\newline$

5.删除 `p` 的后继节点：让 `p` 指向后继节点的后继节点（相当于跳过后继节点了），然后释放原后继节点的空间。故 B 正确。  

$\newline$

6.A 选项体现了数组和指针的重要差别之一，数组名不可以被赋值（即不可以有 `int a[10]; a = b`），但是指针可以（即可以有 `int *a; a = b`）。在我们写 `s="BUAA"` 时，实际上在内存中分配了一段连续的空间，把 "BUAA" 写进去，然后再把这段空间的起始地址赋值给 `s`，但是数组名不能被赋值，所以错误。  

B 选项中 `sp` 是一个 `char` 类型的指针，所以 `*sp` 得到的是一个 `char`，不能把一个地址赋值给一个 `char`（B 选项的关键在于理解 `*` 的含义）。  

C 选项正确，定义了一个 `char` 类型的指针，并把字符串常量 `BUAA` 的起始地址赋值给了这个指针。  

D 选项不正确，跟 B 一个问题。  

$\newline$

7.顺序存储与链式存储常用操作的时间复杂度比较：

<img src="D:\BUAA_DB\img\2020_5.png" style="width: 70%;">

存取第 $\mathrm{i}$ 个元素的值分为两步：找到第 $\mathrm{i}$ 个元素 $\mathrm{\rightarrow}$ 存取这个元素的值。存取其前驱元素（也就是第 $\mathrm{i - 1}$ 个元素）的值也是类似的，不过在找第 $\mathrm{i - 1}$ 个的时候可以利用已经找到的第 $\mathrm{i}$ 个元素，可能不需要从头开始找了。

四个选项各个操作的时间复杂度比较如下：

|                | 1. 找到第 i 个元素 | 2. 存取第 i 个元素的值 | 3. 找到第 i - 1 个元素                 | 4. 存储第 i - 1 个元素的值 |
| -------------- | ------------------ | ---------------------- | -------------------------------------- | -------------------------- |
| **单链表**     | O(n)               | O(1)                   | O(n) （还要从头开始找）                | O(1)                       |
| **双链表**     | O(n)               | O(1)                   | O(1) （直接访问第 i 个元素的前驱字段） | O(1)                       |
| **顺序表**     | O(1)               | O(1)                   | O(1)                                   | O(1)                       |
| **循环单链表** | O(n)               | O(1)                   | O(n) （还要从头开始找）                | O(1)                       |

综上，顺序表各个操作的效率最高。

$\newline$

## 填空题

1.自己编程运行一下或者手动模拟一下即可，答案为 `292`。

$\newline$

2.我们要在填的空上写一个长度，用来作为 `malloc` 的参数，开辟指定大小的空间来存储读入的 `buf`，而且还要尽可能小。开辟的新空间，要能容纳下 `buf` 包含的所有字符，同时还要留一个位置容纳一个空字符，如果没有空字符的话，可能把 `buf` 存进去后 `buf` 后面跟着的其它非空字符也会被当做 `buf` 的一部分，无法正确地拆分出 `buf`（这部分可以参考 `作业讲解/第四次作业/题面详解/D 字符串` 部分）。

所以要填 `strlen(buf) + 1`。

**当处理字符串的时候，千万要注意空字符**！

$\newline$

3.这里就是要了解一下结构体的成员可以是其它结构类型的变量。填 `tr.b.x`。

$\newline$

### 编程题

1.这道题简单来说分成两步：

- 读入字符串 `str`，对其进行预处理，然后逆转得到字符串 `rev` 
- 从 `a` 到 `z` 依次取出不在 `str` 中的字母，然后逆转后接在 `rev` 后面

我们可以用到头文件 `<ctype.h>`，这个头文件提供了很多字符判断或简单字符处理的方法（注意是字符，而不是字符串）。

同时我们还需要去掉 `str` 中的重复字母，记录哪些字母在 `str` 中出现过。这里我们可以使用惯用的简单哈希思想，用 `vis[i]` 标识字母 `i + 'a'` 是否出现过（比如 `vis[0]` 标识字母 `a` 是否出现过，`vis[1]` 标识字母 `b` 是否出现过，依次类推）。

第一步：

```c
scanf("%s", str);
int len = strlen(str);

for(int i = 0; i < len; i++) {
    // 如果是字母，而且之前没有出现过
    if(isalpha(str[i]) && !vis[str[i] - 'a']) {
        // 转换为对应的小写字母
        str[i] = tolower(str[i]);
        vis[str[i] - 'a'] = 1;
        rev[revLen++] = str[i];
    }
}
// 逆转
strrev(rev);
```

第二步：

```c
// 检查没出现过的字母
for(int i = 0; i < 26; i++) {
    if(!vis[i]) 
        tem[temLen++] = 'a' + i;
}
// 逆转后，接在 rev 的后面
strcat(rev, strrev(tem));
```

这道题的完整代码可以参考 `往年期中/参考代码/2022_1.c`。